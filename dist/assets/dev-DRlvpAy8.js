(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const i of r.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function e(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(n){if(n.ep)return;n.ep=!0;const r=e(n);fetch(n.href,r)}})();const P=1e-6,it=new Float32Array([1,0,0,0,1,0,0,0,1]);class O extends Float32Array{static BYTE_LENGTH=9*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 9:super(t);break;case 2:super(t[0],t[1],9);break;case 1:const e=t[0];typeof e=="number"?super([e,e,e,e,e,e,e,e,e]):super(e,0,9);break;default:super(it);break}}get str(){return O.str(this)}copy(t){return this.set(t),this}identity(){return this.set(it),this}multiply(t){return O.multiply(this,this,t)}mul(t){return this}transpose(){return O.transpose(this,this)}invert(){return O.invert(this,this)}translate(t){return O.translate(this,this,t)}rotate(t){return O.rotate(this,this,t)}scale(t){return O.scale(this,this,t)}static create(){return new O}static clone(t){return new O(t)}static copy(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}static fromValues(...t){return new O(...t)}static set(t,...e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}static identity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}static transpose(t,e){if(t===e){const s=e[1],n=e[2],r=e[5];t[1]=e[3],t[2]=e[6],t[3]=s,t[5]=e[7],t[6]=n,t[7]=r}else t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8];return t}static invert(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=e[4],a=e[5],h=e[6],o=e[7],l=e[8],d=l*c-a*o,f=-l*i+a*h,m=o*i-c*h;let p=s*d+n*f+r*m;return p?(p=1/p,t[0]=d*p,t[1]=(-l*n+r*o)*p,t[2]=(a*n-r*c)*p,t[3]=f*p,t[4]=(l*s-r*h)*p,t[5]=(-a*s+r*i)*p,t[6]=m*p,t[7]=(-o*s+n*h)*p,t[8]=(c*s-n*i)*p,t):null}static adjoint(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=e[4],a=e[5],h=e[6],o=e[7],l=e[8];return t[0]=c*l-a*o,t[1]=r*o-n*l,t[2]=n*a-r*c,t[3]=a*h-i*l,t[4]=s*l-r*h,t[5]=r*i-s*a,t[6]=i*o-c*h,t[7]=n*h-s*o,t[8]=s*c-n*i,t}static determinant(t){const e=t[0],s=t[1],n=t[2],r=t[3],i=t[4],c=t[5],a=t[6],h=t[7],o=t[8];return e*(o*i-c*h)+s*(-o*r+c*a)+n*(h*r-i*a)}static add(t,e,s){return t[0]=e[0]+s[0],t[1]=e[1]+s[1],t[2]=e[2]+s[2],t[3]=e[3]+s[3],t[4]=e[4]+s[4],t[5]=e[5]+s[5],t[6]=e[6]+s[6],t[7]=e[7]+s[7],t[8]=e[8]+s[8],t}static subtract(t,e,s){return t[0]=e[0]-s[0],t[1]=e[1]-s[1],t[2]=e[2]-s[2],t[3]=e[3]-s[3],t[4]=e[4]-s[4],t[5]=e[5]-s[5],t[6]=e[6]-s[6],t[7]=e[7]-s[7],t[8]=e[8]-s[8],t}static sub(t,e,s){return t}static multiply(t,e,s){const n=e[0],r=e[1],i=e[2],c=e[3],a=e[4],h=e[5],o=e[6],l=e[7],d=e[8];let f=s[0],m=s[1],p=s[2];return t[0]=f*n+m*c+p*o,t[1]=f*r+m*a+p*l,t[2]=f*i+m*h+p*d,f=s[3],m=s[4],p=s[5],t[3]=f*n+m*c+p*o,t[4]=f*r+m*a+p*l,t[5]=f*i+m*h+p*d,f=s[6],m=s[7],p=s[8],t[6]=f*n+m*c+p*o,t[7]=f*r+m*a+p*l,t[8]=f*i+m*h+p*d,t}static mul(t,e,s){return t}static translate(t,e,s){const n=e[0],r=e[1],i=e[2],c=e[3],a=e[4],h=e[5],o=e[6],l=e[7],d=e[8],f=s[0],m=s[1];return t[0]=n,t[1]=r,t[2]=i,t[3]=c,t[4]=a,t[5]=h,t[6]=f*n+m*c+o,t[7]=f*r+m*a+l,t[8]=f*i+m*h+d,t}static rotate(t,e,s){const n=e[0],r=e[1],i=e[2],c=e[3],a=e[4],h=e[5],o=e[6],l=e[7],d=e[8],f=Math.sin(s),m=Math.cos(s);return t[0]=m*n+f*c,t[1]=m*r+f*a,t[2]=m*i+f*h,t[3]=m*c-f*n,t[4]=m*a-f*r,t[5]=m*h-f*i,t[6]=o,t[7]=l,t[8]=d,t}static scale(t,e,s){const n=s[0],r=s[1];return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=r*e[3],t[4]=r*e[4],t[5]=r*e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}static fromTranslation(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=e[0],t[7]=e[1],t[8]=1,t}static fromRotation(t,e){const s=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=s,t[2]=0,t[3]=-s,t[4]=n,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}static fromScaling(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=e[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}static fromMat2d(t,e){return t[0]=e[0],t[1]=e[1],t[2]=0,t[3]=e[2],t[4]=e[3],t[5]=0,t[6]=e[4],t[7]=e[5],t[8]=1,t}static fromQuat(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=s+s,a=n+n,h=r+r,o=s*c,l=n*c,d=n*a,f=r*c,m=r*a,p=r*h,y=i*c,M=i*a,x=i*h;return t[0]=1-d-p,t[3]=l-x,t[6]=f+M,t[1]=l+x,t[4]=1-o-p,t[7]=m-y,t[2]=f-M,t[5]=m+y,t[8]=1-o-d,t}static fromMat4(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10],t}static normalFromMat4(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=e[4],a=e[5],h=e[6],o=e[7],l=e[8],d=e[9],f=e[10],m=e[11],p=e[12],y=e[13],M=e[14],x=e[15],g=s*a-n*c,w=s*h-r*c,A=s*o-i*c,T=n*h-r*a,E=n*o-i*a,S=r*o-i*h,R=l*y-d*p,U=l*M-f*p,z=l*x-m*p,N=d*M-f*y,I=d*x-m*y,D=f*x-m*M;let F=g*D-w*I+A*N+T*z-E*U+S*R;return F?(F=1/F,t[0]=(a*D-h*I+o*N)*F,t[1]=(h*z-c*D-o*U)*F,t[2]=(c*I-a*z+o*R)*F,t[3]=(r*I-n*D-i*N)*F,t[4]=(s*D-r*z+i*U)*F,t[5]=(n*z-s*I-i*R)*F,t[6]=(y*S-M*E+x*T)*F,t[7]=(M*A-p*S-x*w)*F,t[8]=(p*E-y*A+x*g)*F,t):null}static projection(t,e,s){return t[0]=2/e,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/s,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t}static frob(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]+t[4]*t[4]+t[5]*t[5]+t[6]*t[6]+t[7]*t[7]+t[8]*t[8])}static multiplyScalar(t,e,s){return t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t[3]=e[3]*s,t[4]=e[4]*s,t[5]=e[5]*s,t[6]=e[6]*s,t[7]=e[7]*s,t[8]=e[8]*s,t}static multiplyScalarAndAdd(t,e,s,n){return t[0]=e[0]+s[0]*n,t[1]=e[1]+s[1]*n,t[2]=e[2]+s[2]*n,t[3]=e[3]+s[3]*n,t[4]=e[4]+s[4]*n,t[5]=e[5]+s[5]*n,t[6]=e[6]+s[6]*n,t[7]=e[7]+s[7]*n,t[8]=e[8]+s[8]*n,t}static exactEquals(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]}static equals(t,e){const s=t[0],n=t[1],r=t[2],i=t[3],c=t[4],a=t[5],h=t[6],o=t[7],l=t[8],d=e[0],f=e[1],m=e[2],p=e[3],y=e[4],M=e[5],x=e[6],g=e[7],w=e[8];return Math.abs(s-d)<=P*Math.max(1,Math.abs(s),Math.abs(d))&&Math.abs(n-f)<=P*Math.max(1,Math.abs(n),Math.abs(f))&&Math.abs(r-m)<=P*Math.max(1,Math.abs(r),Math.abs(m))&&Math.abs(i-p)<=P*Math.max(1,Math.abs(i),Math.abs(p))&&Math.abs(c-y)<=P*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(a-M)<=P*Math.max(1,Math.abs(a),Math.abs(M))&&Math.abs(h-x)<=P*Math.max(1,Math.abs(h),Math.abs(x))&&Math.abs(o-g)<=P*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(l-w)<=P*Math.max(1,Math.abs(l),Math.abs(w))}static str(t){return`Mat3(${t.join(", ")})`}}O.prototype.mul=O.prototype.multiply;O.mul=O.multiply;O.sub=O.subtract;class b extends Float32Array{static BYTE_LENGTH=3*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 3:super(t);break;case 2:super(t[0],t[1],3);break;case 1:{const e=t[0];typeof e=="number"?super([e,e,e]):super(e,0,3);break}default:super(3);break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get b(){return this[2]}set b(t){this[2]=t}get magnitude(){const t=this[0],e=this[1],s=this[2];return Math.sqrt(t*t+e*e+s*s)}get mag(){return this.magnitude}get squaredMagnitude(){const t=this[0],e=this[1],s=this[2];return t*t+e*e+s*s}get sqrMag(){return this.squaredMagnitude}get str(){return b.str(this)}copy(t){return this.set(t),this}add(t){return this[0]+=t[0],this[1]+=t[1],this[2]+=t[2],this}subtract(t){return this[0]-=t[0],this[1]-=t[1],this[2]-=t[2],this}sub(t){return this}multiply(t){return this[0]*=t[0],this[1]*=t[1],this[2]*=t[2],this}mul(t){return this}divide(t){return this[0]/=t[0],this[1]/=t[1],this[2]/=t[2],this}div(t){return this}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this}scaleAndAdd(t,e){return this[0]+=t[0]*e,this[1]+=t[1]*e,this[2]+=t[2]*e,this}distance(t){return b.distance(this,t)}dist(t){return 0}squaredDistance(t){return b.squaredDistance(this,t)}sqrDist(t){return 0}negate(){return this[0]*=-1,this[1]*=-1,this[2]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this}dot(t){return this[0]*t[0]+this[1]*t[1]+this[2]*t[2]}normalize(){return b.normalize(this,this)}static create(){return new b}static clone(t){return new b(t)}static magnitude(t){let e=t[0],s=t[1],n=t[2];return Math.sqrt(e*e+s*s+n*n)}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static fromValues(t,e,s){return new b(t,e,s)}static copy(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}static set(t,e,s,n){return t[0]=e,t[1]=s,t[2]=n,t}static add(t,e,s){return t[0]=e[0]+s[0],t[1]=e[1]+s[1],t[2]=e[2]+s[2],t}static subtract(t,e,s){return t[0]=e[0]-s[0],t[1]=e[1]-s[1],t[2]=e[2]-s[2],t}static sub(t,e,s){return[0,0,0]}static multiply(t,e,s){return t[0]=e[0]*s[0],t[1]=e[1]*s[1],t[2]=e[2]*s[2],t}static mul(t,e,s){return[0,0,0]}static divide(t,e,s){return t[0]=e[0]/s[0],t[1]=e[1]/s[1],t[2]=e[2]/s[2],t}static div(t,e,s){return[0,0,0]}static ceil(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t}static floor(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t}static min(t,e,s){return t[0]=Math.min(e[0],s[0]),t[1]=Math.min(e[1],s[1]),t[2]=Math.min(e[2],s[2]),t}static max(t,e,s){return t[0]=Math.max(e[0],s[0]),t[1]=Math.max(e[1],s[1]),t[2]=Math.max(e[2],s[2]),t}static scale(t,e,s){return t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t}static scaleAndAdd(t,e,s,n){return t[0]=e[0]+s[0]*n,t[1]=e[1]+s[1]*n,t[2]=e[2]+s[2]*n,t}static distance(t,e){const s=e[0]-t[0],n=e[1]-t[1],r=e[2]-t[2];return Math.sqrt(s*s+n*n+r*r)}static dist(t,e){return 0}static squaredDistance(t,e){const s=e[0]-t[0],n=e[1]-t[1],r=e[2]-t[2];return s*s+n*n+r*r}static sqrDist(t,e){return 0}static squaredLength(t){const e=t[0],s=t[1],n=t[2];return e*e+s*s+n*n}static sqrLen(t,e){return 0}static negate(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t}static inverse(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t}static normalize(t,e){const s=e[0],n=e[1],r=e[2];let i=s*s+n*n+r*r;return i>0&&(i=1/Math.sqrt(i)),t[0]=e[0]*i,t[1]=e[1]*i,t[2]=e[2]*i,t}static dot(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}static cross(t,e,s){const n=e[0],r=e[1],i=e[2],c=s[0],a=s[1],h=s[2];return t[0]=r*h-i*a,t[1]=i*c-n*h,t[2]=n*a-r*c,t}static lerp(t,e,s,n){const r=e[0],i=e[1],c=e[2];return t[0]=r+n*(s[0]-r),t[1]=i+n*(s[1]-i),t[2]=c+n*(s[2]-c),t}static slerp(t,e,s,n){const r=Math.acos(Math.min(Math.max(b.dot(e,s),-1),1)),i=Math.sin(r),c=Math.sin((1-n)*r)/i,a=Math.sin(n*r)/i;return t[0]=c*e[0]+a*s[0],t[1]=c*e[1]+a*s[1],t[2]=c*e[2]+a*s[2],t}static hermite(t,e,s,n,r,i){const c=i*i,a=c*(2*i-3)+1,h=c*(i-2)+i,o=c*(i-1),l=c*(3-2*i);return t[0]=e[0]*a+s[0]*h+n[0]*o+r[0]*l,t[1]=e[1]*a+s[1]*h+n[1]*o+r[1]*l,t[2]=e[2]*a+s[2]*h+n[2]*o+r[2]*l,t}static bezier(t,e,s,n,r,i){const c=1-i,a=c*c,h=i*i,o=a*c,l=3*i*a,d=3*h*c,f=h*i;return t[0]=e[0]*o+s[0]*l+n[0]*d+r[0]*f,t[1]=e[1]*o+s[1]*l+n[1]*d+r[1]*f,t[2]=e[2]*o+s[2]*l+n[2]*d+r[2]*f,t}static transformMat4(t,e,s){const n=e[0],r=e[1],i=e[2],c=s[3]*n+s[7]*r+s[11]*i+s[15]||1;return t[0]=(s[0]*n+s[4]*r+s[8]*i+s[12])/c,t[1]=(s[1]*n+s[5]*r+s[9]*i+s[13])/c,t[2]=(s[2]*n+s[6]*r+s[10]*i+s[14])/c,t}static transformMat3(t,e,s){let n=e[0],r=e[1],i=e[2];return t[0]=n*s[0]+r*s[3]+i*s[6],t[1]=n*s[1]+r*s[4]+i*s[7],t[2]=n*s[2]+r*s[5]+i*s[8],t}static transformQuat(t,e,s){const n=s[0],r=s[1],i=s[2],c=s[3]*2,a=e[0],h=e[1],o=e[2],l=r*o-i*h,d=i*a-n*o,f=n*h-r*a,m=(r*f-i*d)*2,p=(i*l-n*f)*2,y=(n*d-r*l)*2;return t[0]=a+l*c+m,t[1]=h+d*c+p,t[2]=o+f*c+y,t}static rotateX(t,e,s,n){const r=s[1],i=s[2],c=e[1]-r,a=e[2]-i;return t[0]=e[0],t[1]=c*Math.cos(n)-a*Math.sin(n)+r,t[2]=c*Math.sin(n)+a*Math.cos(n)+i,t}static rotateY(t,e,s,n){const r=s[0],i=s[2],c=e[0]-r,a=e[2]-i;return t[0]=a*Math.sin(n)+c*Math.cos(n)+r,t[1]=e[1],t[2]=a*Math.cos(n)-c*Math.sin(n)+i,t}static rotateZ(t,e,s,n){const r=s[0],i=s[1],c=e[0]-r,a=e[1]-i;return t[0]=c*Math.cos(n)-a*Math.sin(n)+r,t[1]=c*Math.sin(n)+a*Math.cos(n)+i,t[2]=s[2],t}static angle(t,e){const s=t[0],n=t[1],r=t[2],i=e[0],c=e[1],a=e[2],h=Math.sqrt((s*s+n*n+r*r)*(i*i+c*c+a*a)),o=h&&b.dot(t,e)/h;return Math.acos(Math.min(Math.max(o,-1),1))}static zero(t){return t[0]=0,t[1]=0,t[2]=0,t}static str(t){return`Vec3(${t.join(", ")})`}static exactEquals(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]}static equals(t,e){const s=t[0],n=t[1],r=t[2],i=e[0],c=e[1],a=e[2];return Math.abs(s-i)<=P*Math.max(1,Math.abs(s),Math.abs(i))&&Math.abs(n-c)<=P*Math.max(1,Math.abs(n),Math.abs(c))&&Math.abs(r-a)<=P*Math.max(1,Math.abs(r),Math.abs(a))}}b.prototype.sub=b.prototype.subtract;b.prototype.mul=b.prototype.multiply;b.prototype.div=b.prototype.divide;b.prototype.dist=b.prototype.distance;b.prototype.sqrDist=b.prototype.squaredDistance;b.sub=b.subtract;b.mul=b.multiply;b.div=b.divide;b.dist=b.distance;b.sqrDist=b.squaredDistance;b.sqrLen=b.squaredLength;b.mag=b.magnitude;b.length=b.magnitude;b.len=b.magnitude;const ct=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);class v extends Float32Array{static BYTE_LENGTH=16*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 16:super(t);break;case 2:super(t[0],t[1],16);break;case 1:const e=t[0];typeof e=="number"?super([e,e,e,e,e,e,e,e,e,e,e,e,e,e,e,e]):super(e,0,16);break;default:super(ct);break}}get str(){return v.str(this)}copy(t){return this.set(t),this}identity(){return this.set(ct),this}multiply(t){return v.multiply(this,this,t)}mul(t){return this}transpose(){return v.transpose(this,this)}invert(){return v.invert(this,this)}translate(t){return v.translate(this,this,t)}rotate(t,e){return v.rotate(this,this,t,e)}scale(t){return v.scale(this,this,t)}rotateX(t){return v.rotateX(this,this,t)}rotateY(t){return v.rotateY(this,this,t)}rotateZ(t){return v.rotateZ(this,this,t)}perspectiveNO(t,e,s,n){return v.perspectiveNO(this,t,e,s,n)}perspectiveZO(t,e,s,n){return v.perspectiveZO(this,t,e,s,n)}orthoNO(t,e,s,n,r,i){return v.orthoNO(this,t,e,s,n,r,i)}orthoZO(t,e,s,n,r,i){return v.orthoZO(this,t,e,s,n,r,i)}static create(){return new v}static clone(t){return new v(t)}static copy(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}static fromValues(...t){return new v(...t)}static set(t,...e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}static identity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static transpose(t,e){if(t===e){const s=e[1],n=e[2],r=e[3],i=e[6],c=e[7],a=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=s,t[6]=e[9],t[7]=e[13],t[8]=n,t[9]=i,t[11]=e[14],t[12]=r,t[13]=c,t[14]=a}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}static invert(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=e[4],a=e[5],h=e[6],o=e[7],l=e[8],d=e[9],f=e[10],m=e[11],p=e[12],y=e[13],M=e[14],x=e[15],g=s*a-n*c,w=s*h-r*c,A=s*o-i*c,T=n*h-r*a,E=n*o-i*a,S=r*o-i*h,R=l*y-d*p,U=l*M-f*p,z=l*x-m*p,N=d*M-f*y,I=d*x-m*y,D=f*x-m*M;let F=g*D-w*I+A*N+T*z-E*U+S*R;return F?(F=1/F,t[0]=(a*D-h*I+o*N)*F,t[1]=(r*I-n*D-i*N)*F,t[2]=(y*S-M*E+x*T)*F,t[3]=(f*E-d*S-m*T)*F,t[4]=(h*z-c*D-o*U)*F,t[5]=(s*D-r*z+i*U)*F,t[6]=(M*A-p*S-x*w)*F,t[7]=(l*S-f*A+m*w)*F,t[8]=(c*I-a*z+o*R)*F,t[9]=(n*z-s*I-i*R)*F,t[10]=(p*E-y*A+x*g)*F,t[11]=(d*A-l*E-m*g)*F,t[12]=(a*U-c*N-h*R)*F,t[13]=(s*N-n*U+r*R)*F,t[14]=(y*w-p*T-M*g)*F,t[15]=(l*T-d*w+f*g)*F,t):null}static adjoint(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=e[4],a=e[5],h=e[6],o=e[7],l=e[8],d=e[9],f=e[10],m=e[11],p=e[12],y=e[13],M=e[14],x=e[15],g=s*a-n*c,w=s*h-r*c,A=s*o-i*c,T=n*h-r*a,E=n*o-i*a,S=r*o-i*h,R=l*y-d*p,U=l*M-f*p,z=l*x-m*p,N=d*M-f*y,I=d*x-m*y,D=f*x-m*M;return t[0]=a*D-h*I+o*N,t[1]=r*I-n*D-i*N,t[2]=y*S-M*E+x*T,t[3]=f*E-d*S-m*T,t[4]=h*z-c*D-o*U,t[5]=s*D-r*z+i*U,t[6]=M*A-p*S-x*w,t[7]=l*S-f*A+m*w,t[8]=c*I-a*z+o*R,t[9]=n*z-s*I-i*R,t[10]=p*E-y*A+x*g,t[11]=d*A-l*E-m*g,t[12]=a*U-c*N-h*R,t[13]=s*N-n*U+r*R,t[14]=y*w-p*T-M*g,t[15]=l*T-d*w+f*g,t}static determinant(t){const e=t[0],s=t[1],n=t[2],r=t[3],i=t[4],c=t[5],a=t[6],h=t[7],o=t[8],l=t[9],d=t[10],f=t[11],m=t[12],p=t[13],y=t[14],M=t[15],x=e*c-s*i,g=e*a-n*i,w=s*a-n*c,A=o*p-l*m,T=o*y-d*m,E=l*y-d*p,S=e*E-s*T+n*A,R=i*E-c*T+a*A,U=o*w-l*g+d*x,z=m*w-p*g+y*x;return h*S-r*R+M*U-f*z}static multiply(t,e,s){const n=e[0],r=e[1],i=e[2],c=e[3],a=e[4],h=e[5],o=e[6],l=e[7],d=e[8],f=e[9],m=e[10],p=e[11],y=e[12],M=e[13],x=e[14],g=e[15];let w=s[0],A=s[1],T=s[2],E=s[3];return t[0]=w*n+A*a+T*d+E*y,t[1]=w*r+A*h+T*f+E*M,t[2]=w*i+A*o+T*m+E*x,t[3]=w*c+A*l+T*p+E*g,w=s[4],A=s[5],T=s[6],E=s[7],t[4]=w*n+A*a+T*d+E*y,t[5]=w*r+A*h+T*f+E*M,t[6]=w*i+A*o+T*m+E*x,t[7]=w*c+A*l+T*p+E*g,w=s[8],A=s[9],T=s[10],E=s[11],t[8]=w*n+A*a+T*d+E*y,t[9]=w*r+A*h+T*f+E*M,t[10]=w*i+A*o+T*m+E*x,t[11]=w*c+A*l+T*p+E*g,w=s[12],A=s[13],T=s[14],E=s[15],t[12]=w*n+A*a+T*d+E*y,t[13]=w*r+A*h+T*f+E*M,t[14]=w*i+A*o+T*m+E*x,t[15]=w*c+A*l+T*p+E*g,t}static mul(t,e,s){return t}static translate(t,e,s){const n=s[0],r=s[1],i=s[2];if(e===t)t[12]=e[0]*n+e[4]*r+e[8]*i+e[12],t[13]=e[1]*n+e[5]*r+e[9]*i+e[13],t[14]=e[2]*n+e[6]*r+e[10]*i+e[14],t[15]=e[3]*n+e[7]*r+e[11]*i+e[15];else{const c=e[0],a=e[1],h=e[2],o=e[3],l=e[4],d=e[5],f=e[6],m=e[7],p=e[8],y=e[9],M=e[10],x=e[11];t[0]=c,t[1]=a,t[2]=h,t[3]=o,t[4]=l,t[5]=d,t[6]=f,t[7]=m,t[8]=p,t[9]=y,t[10]=M,t[11]=x,t[12]=c*n+l*r+p*i+e[12],t[13]=a*n+d*r+y*i+e[13],t[14]=h*n+f*r+M*i+e[14],t[15]=o*n+m*r+x*i+e[15]}return t}static scale(t,e,s){const n=s[0],r=s[1],i=s[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*r,t[5]=e[5]*r,t[6]=e[6]*r,t[7]=e[7]*r,t[8]=e[8]*i,t[9]=e[9]*i,t[10]=e[10]*i,t[11]=e[11]*i,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}static rotate(t,e,s,n){let r=n[0],i=n[1],c=n[2],a=Math.sqrt(r*r+i*i+c*c);if(a<P)return null;a=1/a,r*=a,i*=a,c*=a;const h=Math.sin(s),o=Math.cos(s),l=1-o,d=e[0],f=e[1],m=e[2],p=e[3],y=e[4],M=e[5],x=e[6],g=e[7],w=e[8],A=e[9],T=e[10],E=e[11],S=r*r*l+o,R=i*r*l+c*h,U=c*r*l-i*h,z=r*i*l-c*h,N=i*i*l+o,I=c*i*l+r*h,D=r*c*l+i*h,F=i*c*l-r*h,q=c*c*l+o;return t[0]=d*S+y*R+w*U,t[1]=f*S+M*R+A*U,t[2]=m*S+x*R+T*U,t[3]=p*S+g*R+E*U,t[4]=d*z+y*N+w*I,t[5]=f*z+M*N+A*I,t[6]=m*z+x*N+T*I,t[7]=p*z+g*N+E*I,t[8]=d*D+y*F+w*q,t[9]=f*D+M*F+A*q,t[10]=m*D+x*F+T*q,t[11]=p*D+g*F+E*q,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t}static rotateX(t,e,s){let n=Math.sin(s),r=Math.cos(s),i=e[4],c=e[5],a=e[6],h=e[7],o=e[8],l=e[9],d=e[10],f=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=i*r+o*n,t[5]=c*r+l*n,t[6]=a*r+d*n,t[7]=h*r+f*n,t[8]=o*r-i*n,t[9]=l*r-c*n,t[10]=d*r-a*n,t[11]=f*r-h*n,t}static rotateY(t,e,s){let n=Math.sin(s),r=Math.cos(s),i=e[0],c=e[1],a=e[2],h=e[3],o=e[8],l=e[9],d=e[10],f=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=i*r-o*n,t[1]=c*r-l*n,t[2]=a*r-d*n,t[3]=h*r-f*n,t[8]=i*n+o*r,t[9]=c*n+l*r,t[10]=a*n+d*r,t[11]=h*n+f*r,t}static rotateZ(t,e,s){let n=Math.sin(s),r=Math.cos(s),i=e[0],c=e[1],a=e[2],h=e[3],o=e[4],l=e[5],d=e[6],f=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=i*r+o*n,t[1]=c*r+l*n,t[2]=a*r+d*n,t[3]=h*r+f*n,t[4]=o*r-i*n,t[5]=l*r-c*n,t[6]=d*r-a*n,t[7]=f*r-h*n,t}static fromTranslation(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}static fromScaling(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromRotation(t,e,s){let n=s[0],r=s[1],i=s[2],c=Math.sqrt(n*n+r*r+i*i);if(c<P)return null;c=1/c,n*=c,r*=c,i*=c;const a=Math.sin(e),h=Math.cos(e),o=1-h;return t[0]=n*n*o+h,t[1]=r*n*o+i*a,t[2]=i*n*o-r*a,t[3]=0,t[4]=n*r*o-i*a,t[5]=r*r*o+h,t[6]=i*r*o+n*a,t[7]=0,t[8]=n*i*o+r*a,t[9]=r*i*o-n*a,t[10]=i*i*o+h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromXRotation(t,e){let s=Math.sin(e),n=Math.cos(e);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=s,t[7]=0,t[8]=0,t[9]=-s,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromYRotation(t,e){let s=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=0,t[2]=-s,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=s,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromZRotation(t,e){const s=Math.sin(e),n=Math.cos(e);return t[0]=n,t[1]=s,t[2]=0,t[3]=0,t[4]=-s,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromRotationTranslation(t,e,s){const n=e[0],r=e[1],i=e[2],c=e[3],a=n+n,h=r+r,o=i+i,l=n*a,d=n*h,f=n*o,m=r*h,p=r*o,y=i*o,M=c*a,x=c*h,g=c*o;return t[0]=1-(m+y),t[1]=d+g,t[2]=f-x,t[3]=0,t[4]=d-g,t[5]=1-(l+y),t[6]=p+M,t[7]=0,t[8]=f+x,t[9]=p-M,t[10]=1-(l+m),t[11]=0,t[12]=s[0],t[13]=s[1],t[14]=s[2],t[15]=1,t}static fromQuat2(t,e){let s=new b;const n=-e[0],r=-e[1],i=-e[2],c=e[3],a=e[4],h=e[5],o=e[6],l=e[7];let d=n*n+r*r+i*i+c*c;return d>0?(s[0]=(a*c+l*n+h*i-o*r)*2/d,s[1]=(h*c+l*r+o*n-a*i)*2/d,s[2]=(o*c+l*i+a*r-h*n)*2/d):(s[0]=(a*c+l*n+h*i-o*r)*2,s[1]=(h*c+l*r+o*n-a*i)*2,s[2]=(o*c+l*i+a*r-h*n)*2),v.fromRotationTranslation(t,e,s),t}static getTranslation(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t}static getScaling(t,e){const s=e[0],n=e[1],r=e[2],i=e[4],c=e[5],a=e[6],h=e[8],o=e[9],l=e[10];return t[0]=Math.sqrt(s*s+n*n+r*r),t[1]=Math.sqrt(i*i+c*c+a*a),t[2]=Math.sqrt(h*h+o*o+l*l),t}static getRotation(t,e){v.getScaling(Z,e);const s=1/Z[0],n=1/Z[1],r=1/Z[2],i=e[0]*s,c=e[1]*n,a=e[2]*r,h=e[4]*s,o=e[5]*n,l=e[6]*r,d=e[8]*s,f=e[9]*n,m=e[10]*r,p=i+o+m;let y=0;return p>0?(y=Math.sqrt(p+1)*2,t[3]=.25*y,t[0]=(l-f)/y,t[1]=(d-a)/y,t[2]=(c-h)/y):i>o&&i>m?(y=Math.sqrt(1+i-o-m)*2,t[3]=(l-f)/y,t[0]=.25*y,t[1]=(c+h)/y,t[2]=(d+a)/y):o>m?(y=Math.sqrt(1+o-i-m)*2,t[3]=(d-a)/y,t[0]=(c+h)/y,t[1]=.25*y,t[2]=(l+f)/y):(y=Math.sqrt(1+m-i-o)*2,t[3]=(c-h)/y,t[0]=(d+a)/y,t[1]=(l+f)/y,t[2]=.25*y),t}static decompose(t,e,s,n){e[0]=n[12],e[1]=n[13],e[2]=n[14];const r=n[0],i=n[1],c=n[2],a=n[4],h=n[5],o=n[6],l=n[8],d=n[9],f=n[10];s[0]=Math.sqrt(r*r+i*i+c*c),s[1]=Math.sqrt(a*a+h*h+o*o),s[2]=Math.sqrt(l*l+d*d+f*f);const m=1/s[0],p=1/s[1],y=1/s[2],M=r*m,x=i*p,g=c*y,w=a*m,A=h*p,T=o*y,E=l*m,S=d*p,R=f*y,U=M+A+R;let z=0;return U>0?(z=Math.sqrt(U+1)*2,t[3]=.25*z,t[0]=(T-S)/z,t[1]=(E-g)/z,t[2]=(x-w)/z):M>A&&M>R?(z=Math.sqrt(1+M-A-R)*2,t[3]=(T-S)/z,t[0]=.25*z,t[1]=(x+w)/z,t[2]=(E+g)/z):A>R?(z=Math.sqrt(1+A-M-R)*2,t[3]=(E-g)/z,t[0]=(x+w)/z,t[1]=.25*z,t[2]=(T+S)/z):(z=Math.sqrt(1+R-M-A)*2,t[3]=(x-w)/z,t[0]=(E+g)/z,t[1]=(T+S)/z,t[2]=.25*z),t}static fromRotationTranslationScale(t,e,s,n){const r=e[0],i=e[1],c=e[2],a=e[3],h=r+r,o=i+i,l=c+c,d=r*h,f=r*o,m=r*l,p=i*o,y=i*l,M=c*l,x=a*h,g=a*o,w=a*l,A=n[0],T=n[1],E=n[2];return t[0]=(1-(p+M))*A,t[1]=(f+w)*A,t[2]=(m-g)*A,t[3]=0,t[4]=(f-w)*T,t[5]=(1-(d+M))*T,t[6]=(y+x)*T,t[7]=0,t[8]=(m+g)*E,t[9]=(y-x)*E,t[10]=(1-(d+p))*E,t[11]=0,t[12]=s[0],t[13]=s[1],t[14]=s[2],t[15]=1,t}static fromRotationTranslationScaleOrigin(t,e,s,n,r){const i=e[0],c=e[1],a=e[2],h=e[3],o=i+i,l=c+c,d=a+a,f=i*o,m=i*l,p=i*d,y=c*l,M=c*d,x=a*d,g=h*o,w=h*l,A=h*d,T=n[0],E=n[1],S=n[2],R=r[0],U=r[1],z=r[2],N=(1-(y+x))*T,I=(m+A)*T,D=(p-w)*T,F=(m-A)*E,q=(1-(f+x))*E,X=(M+g)*E,W=(p+w)*S,$=(M-g)*S,H=(1-(f+y))*S;return t[0]=N,t[1]=I,t[2]=D,t[3]=0,t[4]=F,t[5]=q,t[6]=X,t[7]=0,t[8]=W,t[9]=$,t[10]=H,t[11]=0,t[12]=s[0]+R-(N*R+F*U+W*z),t[13]=s[1]+U-(I*R+q*U+$*z),t[14]=s[2]+z-(D*R+X*U+H*z),t[15]=1,t}static fromQuat(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=s+s,a=n+n,h=r+r,o=s*c,l=n*c,d=n*a,f=r*c,m=r*a,p=r*h,y=i*c,M=i*a,x=i*h;return t[0]=1-d-p,t[1]=l+x,t[2]=f-M,t[3]=0,t[4]=l-x,t[5]=1-o-p,t[6]=m+y,t[7]=0,t[8]=f+M,t[9]=m-y,t[10]=1-o-d,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static frustum(t,e,s,n,r,i,c){const a=1/(s-e),h=1/(r-n),o=1/(i-c);return t[0]=i*2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i*2*h,t[6]=0,t[7]=0,t[8]=(s+e)*a,t[9]=(r+n)*h,t[10]=(c+i)*o,t[11]=-1,t[12]=0,t[13]=0,t[14]=c*i*2*o,t[15]=0,t}static perspectiveNO(t,e,s,n,r){const i=1/Math.tan(e/2);if(t[0]=i/s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,r!=null&&r!==1/0){const c=1/(n-r);t[10]=(r+n)*c,t[14]=2*r*n*c}else t[10]=-1,t[14]=-2*n;return t}static perspective(t,e,s,n,r){return t}static perspectiveZO(t,e,s,n,r){const i=1/Math.tan(e/2);if(t[0]=i/s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,r!=null&&r!==1/0){const c=1/(n-r);t[10]=r*c,t[14]=r*n*c}else t[10]=-1,t[14]=-n;return t}static perspectiveFromFieldOfView(t,e,s,n){const r=Math.tan(e.upDegrees*Math.PI/180),i=Math.tan(e.downDegrees*Math.PI/180),c=Math.tan(e.leftDegrees*Math.PI/180),a=Math.tan(e.rightDegrees*Math.PI/180),h=2/(c+a),o=2/(r+i);return t[0]=h,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=-((c-a)*h*.5),t[9]=(r-i)*o*.5,t[10]=n/(s-n),t[11]=-1,t[12]=0,t[13]=0,t[14]=n*s/(s-n),t[15]=0,t}static orthoNO(t,e,s,n,r,i,c){const a=1/(e-s),h=1/(n-r),o=1/(i-c);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*h,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*o,t[11]=0,t[12]=(e+s)*a,t[13]=(r+n)*h,t[14]=(c+i)*o,t[15]=1,t}static ortho(t,e,s,n,r,i,c){return t}static orthoZO(t,e,s,n,r,i,c){const a=1/(e-s),h=1/(n-r),o=1/(i-c);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*h,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=o,t[11]=0,t[12]=(e+s)*a,t[13]=(r+n)*h,t[14]=i*o,t[15]=1,t}static lookAt(t,e,s,n){const r=e[0],i=e[1],c=e[2],a=n[0],h=n[1],o=n[2],l=s[0],d=s[1],f=s[2];if(Math.abs(r-l)<P&&Math.abs(i-d)<P&&Math.abs(c-f)<P)return v.identity(t);let m=r-l,p=i-d,y=c-f,M=1/Math.sqrt(m*m+p*p+y*y);m*=M,p*=M,y*=M;let x=h*y-o*p,g=o*m-a*y,w=a*p-h*m;M=Math.sqrt(x*x+g*g+w*w),M?(M=1/M,x*=M,g*=M,w*=M):(x=0,g=0,w=0);let A=p*w-y*g,T=y*x-m*w,E=m*g-p*x;return M=Math.sqrt(A*A+T*T+E*E),M?(M=1/M,A*=M,T*=M,E*=M):(A=0,T=0,E=0),t[0]=x,t[1]=A,t[2]=m,t[3]=0,t[4]=g,t[5]=T,t[6]=p,t[7]=0,t[8]=w,t[9]=E,t[10]=y,t[11]=0,t[12]=-(x*r+g*i+w*c),t[13]=-(A*r+T*i+E*c),t[14]=-(m*r+p*i+y*c),t[15]=1,t}static targetTo(t,e,s,n){const r=e[0],i=e[1],c=e[2],a=n[0],h=n[1],o=n[2];let l=r-s[0],d=i-s[1],f=c-s[2],m=l*l+d*d+f*f;m>0&&(m=1/Math.sqrt(m),l*=m,d*=m,f*=m);let p=h*f-o*d,y=o*l-a*f,M=a*d-h*l;return m=p*p+y*y+M*M,m>0&&(m=1/Math.sqrt(m),p*=m,y*=m,M*=m),t[0]=p,t[1]=y,t[2]=M,t[3]=0,t[4]=d*M-f*y,t[5]=f*p-l*M,t[6]=l*y-d*p,t[7]=0,t[8]=l,t[9]=d,t[10]=f,t[11]=0,t[12]=r,t[13]=i,t[14]=c,t[15]=1,t}static frob(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]+t[4]*t[4]+t[5]*t[5]+t[6]*t[6]+t[7]*t[7]+t[8]*t[8]+t[9]*t[9]+t[10]*t[10]+t[11]*t[11]+t[12]*t[12]+t[13]*t[13]+t[14]*t[14]+t[15]*t[15])}static add(t,e,s){return t[0]=e[0]+s[0],t[1]=e[1]+s[1],t[2]=e[2]+s[2],t[3]=e[3]+s[3],t[4]=e[4]+s[4],t[5]=e[5]+s[5],t[6]=e[6]+s[6],t[7]=e[7]+s[7],t[8]=e[8]+s[8],t[9]=e[9]+s[9],t[10]=e[10]+s[10],t[11]=e[11]+s[11],t[12]=e[12]+s[12],t[13]=e[13]+s[13],t[14]=e[14]+s[14],t[15]=e[15]+s[15],t}static subtract(t,e,s){return t[0]=e[0]-s[0],t[1]=e[1]-s[1],t[2]=e[2]-s[2],t[3]=e[3]-s[3],t[4]=e[4]-s[4],t[5]=e[5]-s[5],t[6]=e[6]-s[6],t[7]=e[7]-s[7],t[8]=e[8]-s[8],t[9]=e[9]-s[9],t[10]=e[10]-s[10],t[11]=e[11]-s[11],t[12]=e[12]-s[12],t[13]=e[13]-s[13],t[14]=e[14]-s[14],t[15]=e[15]-s[15],t}static sub(t,e,s){return t}static multiplyScalar(t,e,s){return t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t[3]=e[3]*s,t[4]=e[4]*s,t[5]=e[5]*s,t[6]=e[6]*s,t[7]=e[7]*s,t[8]=e[8]*s,t[9]=e[9]*s,t[10]=e[10]*s,t[11]=e[11]*s,t[12]=e[12]*s,t[13]=e[13]*s,t[14]=e[14]*s,t[15]=e[15]*s,t}static multiplyScalarAndAdd(t,e,s,n){return t[0]=e[0]+s[0]*n,t[1]=e[1]+s[1]*n,t[2]=e[2]+s[2]*n,t[3]=e[3]+s[3]*n,t[4]=e[4]+s[4]*n,t[5]=e[5]+s[5]*n,t[6]=e[6]+s[6]*n,t[7]=e[7]+s[7]*n,t[8]=e[8]+s[8]*n,t[9]=e[9]+s[9]*n,t[10]=e[10]+s[10]*n,t[11]=e[11]+s[11]*n,t[12]=e[12]+s[12]*n,t[13]=e[13]+s[13]*n,t[14]=e[14]+s[14]*n,t[15]=e[15]+s[15]*n,t}static exactEquals(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]&&t[4]===e[4]&&t[5]===e[5]&&t[6]===e[6]&&t[7]===e[7]&&t[8]===e[8]&&t[9]===e[9]&&t[10]===e[10]&&t[11]===e[11]&&t[12]===e[12]&&t[13]===e[13]&&t[14]===e[14]&&t[15]===e[15]}static equals(t,e){const s=t[0],n=t[1],r=t[2],i=t[3],c=t[4],a=t[5],h=t[6],o=t[7],l=t[8],d=t[9],f=t[10],m=t[11],p=t[12],y=t[13],M=t[14],x=t[15],g=e[0],w=e[1],A=e[2],T=e[3],E=e[4],S=e[5],R=e[6],U=e[7],z=e[8],N=e[9],I=e[10],D=e[11],F=e[12],q=e[13],X=e[14],W=e[15];return Math.abs(s-g)<=P*Math.max(1,Math.abs(s),Math.abs(g))&&Math.abs(n-w)<=P*Math.max(1,Math.abs(n),Math.abs(w))&&Math.abs(r-A)<=P*Math.max(1,Math.abs(r),Math.abs(A))&&Math.abs(i-T)<=P*Math.max(1,Math.abs(i),Math.abs(T))&&Math.abs(c-E)<=P*Math.max(1,Math.abs(c),Math.abs(E))&&Math.abs(a-S)<=P*Math.max(1,Math.abs(a),Math.abs(S))&&Math.abs(h-R)<=P*Math.max(1,Math.abs(h),Math.abs(R))&&Math.abs(o-U)<=P*Math.max(1,Math.abs(o),Math.abs(U))&&Math.abs(l-z)<=P*Math.max(1,Math.abs(l),Math.abs(z))&&Math.abs(d-N)<=P*Math.max(1,Math.abs(d),Math.abs(N))&&Math.abs(f-I)<=P*Math.max(1,Math.abs(f),Math.abs(I))&&Math.abs(m-D)<=P*Math.max(1,Math.abs(m),Math.abs(D))&&Math.abs(p-F)<=P*Math.max(1,Math.abs(p),Math.abs(F))&&Math.abs(y-q)<=P*Math.max(1,Math.abs(y),Math.abs(q))&&Math.abs(M-X)<=P*Math.max(1,Math.abs(M),Math.abs(X))&&Math.abs(x-W)<=P*Math.max(1,Math.abs(x),Math.abs(W))}static str(t){return`Mat4(${t.join(", ")})`}}const Z=new b;v.prototype.mul=v.prototype.multiply;v.sub=v.subtract;v.mul=v.multiply;v.perspective=v.perspectiveNO;v.ortho=v.orthoNO;class C extends Float32Array{static BYTE_LENGTH=4*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 4:super(t);break;case 2:super(t[0],t[1],4);break;case 1:{const e=t[0];typeof e=="number"?super([e,e,e,e]):super(e,0,4);break}default:super(4);break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get w(){return this[3]}set w(t){this[3]=t}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get b(){return this[2]}set b(t){this[2]=t}get a(){return this[3]}set a(t){this[3]=t}get magnitude(){const t=this[0],e=this[1],s=this[2],n=this[3];return Math.sqrt(t*t+e*e+s*s+n*n)}get mag(){return this.magnitude}get str(){return C.str(this)}copy(t){return super.set(t),this}add(t){return this[0]+=t[0],this[1]+=t[1],this[2]+=t[2],this[3]+=t[3],this}subtract(t){return this[0]-=t[0],this[1]-=t[1],this[2]-=t[2],this[3]-=t[3],this}sub(t){return this}multiply(t){return this[0]*=t[0],this[1]*=t[1],this[2]*=t[2],this[3]*=t[3],this}mul(t){return this}divide(t){return this[0]/=t[0],this[1]/=t[1],this[2]/=t[2],this[3]/=t[3],this}div(t){return this}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this[3]*=t,this}scaleAndAdd(t,e){return this[0]+=t[0]*e,this[1]+=t[1]*e,this[2]+=t[2]*e,this[3]+=t[3]*e,this}distance(t){return C.distance(this,t)}dist(t){return 0}squaredDistance(t){return C.squaredDistance(this,t)}sqrDist(t){return 0}negate(){return this[0]*=-1,this[1]*=-1,this[2]*=-1,this[3]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this[3]=1/this[3],this}dot(t){return this[0]*t[0]+this[1]*t[1]+this[2]*t[2]+this[3]*t[3]}normalize(){return C.normalize(this,this)}static create(){return new C}static clone(t){return new C(t)}static fromValues(t,e,s,n){return new C(t,e,s,n)}static copy(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}static set(t,e,s,n,r){return t[0]=e,t[1]=s,t[2]=n,t[3]=r,t}static add(t,e,s){return t[0]=e[0]+s[0],t[1]=e[1]+s[1],t[2]=e[2]+s[2],t[3]=e[3]+s[3],t}static subtract(t,e,s){return t[0]=e[0]-s[0],t[1]=e[1]-s[1],t[2]=e[2]-s[2],t[3]=e[3]-s[3],t}static sub(t,e,s){return t}static multiply(t,e,s){return t[0]=e[0]*s[0],t[1]=e[1]*s[1],t[2]=e[2]*s[2],t[3]=e[3]*s[3],t}static mul(t,e,s){return t}static divide(t,e,s){return t[0]=e[0]/s[0],t[1]=e[1]/s[1],t[2]=e[2]/s[2],t[3]=e[3]/s[3],t}static div(t,e,s){return t}static ceil(t,e){return t[0]=Math.ceil(e[0]),t[1]=Math.ceil(e[1]),t[2]=Math.ceil(e[2]),t[3]=Math.ceil(e[3]),t}static floor(t,e){return t[0]=Math.floor(e[0]),t[1]=Math.floor(e[1]),t[2]=Math.floor(e[2]),t[3]=Math.floor(e[3]),t}static min(t,e,s){return t[0]=Math.min(e[0],s[0]),t[1]=Math.min(e[1],s[1]),t[2]=Math.min(e[2],s[2]),t[3]=Math.min(e[3],s[3]),t}static max(t,e,s){return t[0]=Math.max(e[0],s[0]),t[1]=Math.max(e[1],s[1]),t[2]=Math.max(e[2],s[2]),t[3]=Math.max(e[3],s[3]),t}static round(t,e){return t[0]=Math.round(e[0]),t[1]=Math.round(e[1]),t[2]=Math.round(e[2]),t[3]=Math.round(e[3]),t}static scale(t,e,s){return t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t[3]=e[3]*s,t}static scaleAndAdd(t,e,s,n){return t[0]=e[0]+s[0]*n,t[1]=e[1]+s[1]*n,t[2]=e[2]+s[2]*n,t[3]=e[3]+s[3]*n,t}static distance(t,e){const s=e[0]-t[0],n=e[1]-t[1],r=e[2]-t[2],i=e[3]-t[3];return Math.hypot(s,n,r,i)}static dist(t,e){return 0}static squaredDistance(t,e){const s=e[0]-t[0],n=e[1]-t[1],r=e[2]-t[2],i=e[3]-t[3];return s*s+n*n+r*r+i*i}static sqrDist(t,e){return 0}static magnitude(t){const e=t[0],s=t[1],n=t[2],r=t[3];return Math.sqrt(e*e+s*s+n*n+r*r)}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static squaredLength(t){const e=t[0],s=t[1],n=t[2],r=t[3];return e*e+s*s+n*n+r*r}static sqrLen(t){return 0}static negate(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3],t}static inverse(t,e){return t[0]=1/e[0],t[1]=1/e[1],t[2]=1/e[2],t[3]=1/e[3],t}static normalize(t,e){const s=e[0],n=e[1],r=e[2],i=e[3];let c=s*s+n*n+r*r+i*i;return c>0&&(c=1/Math.sqrt(c)),t[0]=s*c,t[1]=n*c,t[2]=r*c,t[3]=i*c,t}static dot(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}static cross(t,e,s,n){const r=s[0]*n[1]-s[1]*n[0],i=s[0]*n[2]-s[2]*n[0],c=s[0]*n[3]-s[3]*n[0],a=s[1]*n[2]-s[2]*n[1],h=s[1]*n[3]-s[3]*n[1],o=s[2]*n[3]-s[3]*n[2],l=e[0],d=e[1],f=e[2],m=e[3];return t[0]=d*o-f*h+m*a,t[1]=-(l*o)+f*c-m*i,t[2]=l*h-d*c+m*r,t[3]=-(l*a)+d*i-f*r,t}static lerp(t,e,s,n){const r=e[0],i=e[1],c=e[2],a=e[3];return t[0]=r+n*(s[0]-r),t[1]=i+n*(s[1]-i),t[2]=c+n*(s[2]-c),t[3]=a+n*(s[3]-a),t}static transformMat4(t,e,s){const n=e[0],r=e[1],i=e[2],c=e[3];return t[0]=s[0]*n+s[4]*r+s[8]*i+s[12]*c,t[1]=s[1]*n+s[5]*r+s[9]*i+s[13]*c,t[2]=s[2]*n+s[6]*r+s[10]*i+s[14]*c,t[3]=s[3]*n+s[7]*r+s[11]*i+s[15]*c,t}static transformQuat(t,e,s){const n=e[0],r=e[1],i=e[2],c=s[0],a=s[1],h=s[2],o=s[3],l=o*n+a*i-h*r,d=o*r+h*n-c*i,f=o*i+c*r-a*n,m=-c*n-a*r-h*i;return t[0]=l*o+m*-c+d*-h-f*-a,t[1]=d*o+m*-a+f*-c-l*-h,t[2]=f*o+m*-h+l*-a-d*-c,t[3]=e[3],t}static zero(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}static str(t){return`Vec4(${t.join(", ")})`}static exactEquals(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}static equals(t,e){const s=t[0],n=t[1],r=t[2],i=t[3],c=e[0],a=e[1],h=e[2],o=e[3];return Math.abs(s-c)<=P*Math.max(1,Math.abs(s),Math.abs(c))&&Math.abs(n-a)<=P*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(r-h)<=P*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(i-o)<=P*Math.max(1,Math.abs(i),Math.abs(o))}}C.prototype.sub=C.prototype.subtract;C.prototype.mul=C.prototype.multiply;C.prototype.div=C.prototype.divide;C.prototype.dist=C.prototype.distance;C.prototype.sqrDist=C.prototype.squaredDistance;C.sub=C.subtract;C.mul=C.multiply;C.div=C.divide;C.dist=C.distance;C.sqrDist=C.squaredDistance;C.sqrLen=C.squaredLength;C.mag=C.magnitude;C.length=C.magnitude;C.len=C.magnitude;class L extends Float32Array{static BYTE_LENGTH=4*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 4:super(t);break;case 2:super(t[0],t[1],4);break;case 1:{const e=t[0];typeof e=="number"?super([e,e,e,e]):super(e,0,4);break}default:super(4),this[3]=1;break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get w(){return this[3]}set w(t){this[3]=t}get magnitude(){const t=this[0],e=this[1],s=this[2],n=this[3];return Math.sqrt(t*t+e*e+s*s+n*n)}get mag(){return this.magnitude}get str(){return L.str(this)}copy(t){return super.set(t),this}identity(){return this[0]=0,this[1]=0,this[2]=0,this[3]=1,this}multiply(t){return L.multiply(this,this,t)}mul(t){return this}rotateX(t){return L.rotateX(this,this,t)}rotateY(t){return L.rotateY(this,this,t)}rotateZ(t){return L.rotateZ(this,this,t)}invert(){return L.invert(this,this)}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this[3]*=t,this}dot(t){return L.dot(this,t)}static create(){return new L}static identity(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}static setAxisAngle(t,e,s){s=s*.5;const n=Math.sin(s);return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=Math.cos(s),t}static getAxisAngle(t,e){const s=Math.acos(e[3])*2,n=Math.sin(s/2);return n>P?(t[0]=e[0]/n,t[1]=e[1]/n,t[2]=e[2]/n):(t[0]=1,t[1]=0,t[2]=0),s}static getAngle(t,e){const s=L.dot(t,e);return Math.acos(2*s*s-1)}static multiply(t,e,s){const n=e[0],r=e[1],i=e[2],c=e[3],a=s[0],h=s[1],o=s[2],l=s[3];return t[0]=n*l+c*a+r*o-i*h,t[1]=r*l+c*h+i*a-n*o,t[2]=i*l+c*o+n*h-r*a,t[3]=c*l-n*a-r*h-i*o,t}static rotateX(t,e,s){s*=.5;const n=e[0],r=e[1],i=e[2],c=e[3],a=Math.sin(s),h=Math.cos(s);return t[0]=n*h+c*a,t[1]=r*h+i*a,t[2]=i*h-r*a,t[3]=c*h-n*a,t}static rotateY(t,e,s){s*=.5;const n=e[0],r=e[1],i=e[2],c=e[3],a=Math.sin(s),h=Math.cos(s);return t[0]=n*h-i*a,t[1]=r*h+c*a,t[2]=i*h+n*a,t[3]=c*h-r*a,t}static rotateZ(t,e,s){s*=.5;const n=e[0],r=e[1],i=e[2],c=e[3],a=Math.sin(s),h=Math.cos(s);return t[0]=n*h+r*a,t[1]=r*h-n*a,t[2]=i*h+c*a,t[3]=c*h-i*a,t}static calculateW(t,e){const s=e[0],n=e[1],r=e[2];return t[0]=s,t[1]=n,t[2]=r,t[3]=Math.sqrt(Math.abs(1-s*s-n*n-r*r)),t}static exp(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=Math.sqrt(s*s+n*n+r*r),a=Math.exp(i),h=c>0?a*Math.sin(c)/c:0;return t[0]=s*h,t[1]=n*h,t[2]=r*h,t[3]=a*Math.cos(c),t}static ln(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=Math.sqrt(s*s+n*n+r*r),a=c>0?Math.atan2(c,i)/c:0;return t[0]=s*a,t[1]=n*a,t[2]=r*a,t[3]=.5*Math.log(s*s+n*n+r*r+i*i),t}static pow(t,e,s){return L.ln(t,e),L.scale(t,t,s),L.exp(t,t),t}static slerp(t,e,s,n){const r=e[0],i=e[1],c=e[2],a=e[3];let h=s[0],o=s[1],l=s[2],d=s[3],f,m,p=r*h+i*o+c*l+a*d;if(p<0&&(p=-p,h=-h,o=-o,l=-l,d=-d),1-p>P){const y=Math.acos(p),M=Math.sin(y);f=Math.sin((1-n)*y)/M,m=Math.sin(n*y)/M}else f=1-n,m=n;return t[0]=f*r+m*h,t[1]=f*i+m*o,t[2]=f*c+m*l,t[3]=f*a+m*d,t}static invert(t,e){const s=e[0],n=e[1],r=e[2],i=e[3],c=s*s+n*n+r*r+i*i,a=c?1/c:0;return t[0]=-s*a,t[1]=-n*a,t[2]=-r*a,t[3]=i*a,t}static conjugate(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t}static fromMat3(t,e){const s=e[0]+e[4]+e[8];let n;if(s>0)n=Math.sqrt(s+1),t[3]=.5*n,n=.5/n,t[0]=(e[5]-e[7])*n,t[1]=(e[6]-e[2])*n,t[2]=(e[1]-e[3])*n;else{let r=0;e[4]>e[0]&&(r=1),e[8]>e[r*3+r]&&(r=2);let i=(r+1)%3,c=(r+2)%3;n=Math.sqrt(e[r*3+r]-e[i*3+i]-e[c*3+c]+1),t[r]=.5*n,n=.5/n,t[3]=(e[i*3+c]-e[c*3+i])*n,t[i]=(e[i*3+r]+e[r*3+i])*n,t[c]=(e[c*3+r]+e[r*3+c])*n}return t}static fromEuler(t,e,s,n){let r=.5*Math.PI/180;e*=r,s*=r,n*=r;let i=Math.sin(e),c=Math.cos(e),a=Math.sin(s),h=Math.cos(s),o=Math.sin(n),l=Math.cos(n);return t[0]=i*h*l-c*a*o,t[1]=c*a*l+i*h*o,t[2]=c*h*o-i*a*l,t[3]=c*h*l+i*a*o,t}static str(t){return`Quat(${t.join(", ")})`}static clone(t){return new L(t)}static fromValues(t,e,s,n){return new L(t,e,s,n)}static copy(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t}static set(t,e,s,n,r){return t}static add(t,e,s){return t}static mul(t,e,s){return t}static scale(t,e,s){return t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t[3]=e[3]*s,t}static dot(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}static lerp(t,e,s,n){return t}static magnitude(t){return 0}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static squaredLength(t){return 0}static sqrLen(t){return 0}static normalize(t,e){return t}static exactEquals(t,e){return!1}static equals(t,e){return!1}static rotationTo(t,e,s){let n=b.dot(e,s);return n<-.999999?(b.cross(j,dt,e),b.len(j)<1e-6&&b.cross(j,mt,e),b.normalize(j,j),L.setAxisAngle(t,j,Math.PI),t):n>.999999?(t[0]=0,t[1]=0,t[2]=0,t[3]=1,t):(b.cross(j,e,s),t[0]=j[0],t[1]=j[1],t[2]=j[2],t[3]=1+n,L.normalize(t,t))}static sqlerp(t,e,s,n,r,i){return L.slerp(at,e,r,i),L.slerp(ht,s,n,i),L.slerp(t,at,ht,2*i*(1-i)),t}static setAxes(t,e,s,n){return G[0]=s[0],G[3]=s[1],G[6]=s[2],G[1]=n[0],G[4]=n[1],G[7]=n[2],G[2]=-e[0],G[5]=-e[1],G[8]=-e[2],L.normalize(t,L.fromMat3(t,G))}}const at=new L,ht=new L,G=new O,j=new b,dt=new b(1,0,0),mt=new b(0,1,0);L.set=C.set;L.add=C.add;L.lerp=C.lerp;L.normalize=C.normalize;L.squaredLength=C.squaredLength;L.sqrLen=C.squaredLength;L.exactEquals=C.exactEquals;L.equals=C.equals;L.magnitude=C.magnitude;L.prototype.mul=L.prototype.multiply;L.mul=L.multiply;L.mag=L.magnitude;L.length=L.magnitude;L.len=L.magnitude;class et{fov;aspect;near;far;active=!0;constructor(t=90,e=1,s=.1,n=1e3){this.fov=t,this.aspect=e,this.near=s,this.far=n}getProjectionMatrix(t){let e=new v;const s=t??this.aspect,n=2*Math.atan(Math.tan(this.fov*Math.PI/360)/s)*180/Math.PI;return v.perspectiveNO(e,n*Math.PI/180,s,this.near,this.far),e}setActive(t){this.active=t}}class V{static cache=new Map;static async fetchArrayBuffer(t,e){const s=await fetch(t,e);if(!s.ok)throw new Error(`Failed to fetch ${t}: ${s.status} ${s.statusText}`);return await s.arrayBuffer()}static async fetchText(t,e){const s=await fetch(t,e);if(!s.ok)throw new Error(`Failed to fetch ${t}: ${s.status} ${s.statusText}`);return await s.text()}static loadImage(t,e="anonymous"){return new Promise((s,n)=>{const r=new Image;e&&(r.crossOrigin=e),r.onload=()=>s(r),r.onerror=()=>n(new Error(`Failed to load image: ${t}`)),r.src=t})}static async loadResource(t,e){const s=this.cache.get(t);if(s)return s;const n=this._getExtension(t).toLowerCase(),r=e||this._mimeFromExtension(n)||void 0;let i;try{r&&r.startsWith("image/")?i={type:"image",data:await this.loadImage(t),mime:r}:n==="obj"||n==="mtl"||n==="gltf"||n==="glsl"||n==="vs"||n==="fs"||n==="txt"||n==="json"?i={type:"text",data:await this.fetchText(t),mime:r}:n==="glb"||n==="bin"||n==="fbx"||n==="dae"||n==="stl"?i={type:"arraybuffer",data:await this.fetchArrayBuffer(t),mime:r}:i={type:"arraybuffer",data:await this.fetchArrayBuffer(t),mime:r}}catch(c){return console.error(`Failed to load resource ${t}: ${c.message}`),null}return this.cache.set(t,i),i}static loadedResourceToText(t=null){return t?t.type==="text"?t.data:t.type==="arraybuffer"?new TextDecoder().decode(t.data):(t.type==="image"&&console.error("Cannot convert image resource to text"),""):null}static getCached(t){return this.cache.get(t)}static clearCache(){this.cache.clear()}static _getExtension(t){try{const s=new URL(t,location.href).pathname,n=s.lastIndexOf(".");return n>=0?s.substring(n+1):""}catch{const s=t.lastIndexOf(".");return s>=0?t.substring(s+1):""}}static _mimeFromExtension(t){switch(t){case"png":return"image/png";case"jpg":case"jpeg":return"image/jpeg";case"gif":return"image/gif";case"webp":return"image/webp";case"bmp":return"image/bmp";case"obj":return"text/plain";case"gltf":return"application/json";case"glb":return"model/gltf-binary";case"bin":return"application/octet-stream";case"fbx":return"application/octet-stream";case"stl":return"application/sla";case"vs":case"fs":case"glsl":return"text/plain";case"json":return"application/json";case"txt":return"text/plain";default:return null}}}class pt{static cache=new Map;static async loadTexture(t,e,s=!0,n=!0){if(this.cache.has(e))return this.cache.get(e);const r=await V.loadResource(e);if(!r)return console.error(`Failed to load texture: ${e}`),null;let i=null;if(r.type==="image")i=r.data;else if(r.type==="arraybuffer"){const a=new Blob([r.data]),h=URL.createObjectURL(a);try{i=await V.loadImage(h)}finally{URL.revokeObjectURL(h)}}else if(r.type==="text"){const a=new Blob([r.data]),h=URL.createObjectURL(a);try{i=await V.loadImage(h)}finally{URL.revokeObjectURL(h)}}if(!i)throw new Error(`Failed to load image resource: ${e}`);const c=t.createTexture();if(!c)throw new Error("Impossible de créer la texture WebGL");return t.bindTexture(t.TEXTURE_2D,c),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,s?1:0),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,i),ot(i.width)&&ot(i.height)&&n?(t.generateMipmap(t.TEXTURE_2D),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR)):t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),t.bindTexture(t.TEXTURE_2D,null),this.cache.set(e,c),c}static getCached(t){return this.cache.get(t)}static deleteTexture(t,e){const s=this.cache.get(e);s&&(t.deleteTexture(s),this.cache.delete(e))}static clearCache(t){if(t)for(const e of this.cache.values())t.deleteTexture(e);this.cache.clear()}}function ot(B){return(B&B-1)===0}class lt{vertexShader;fragmentShader;geometryShader;tessControlShader;tessEvalShader;constructor(t,e,s,n,r){this.vertexShader=t,this.fragmentShader=e,this.geometryShader=s,this.tessControlShader=n,this.tessEvalShader=r}}class yt{static async LoadShaderFile(t){const e=await fetch(t);if(!e.ok)throw new Error(`Erreur lors du chargement du shader: ${t}`);return await e.text()}static async LoadShaderFolder(t){t.endsWith("/")||(t+="/"),console.log("Try to load shaders from folder",t);const s=(t.endsWith("/")?t:t+"/").split("/").filter(Boolean),n=s[s.length-1],r=[{ext:".vs",key:"vertexShader"},{ext:".fs",key:"fragmentShader"},{ext:".gs",key:"geometryShader"},{ext:".ts",key:"tessControlShader"},{ext:".tes",key:"tessEvalShader"}];let i="",c="",a,h,o;if(await Promise.all(r.map(async({ext:l,key:d})=>{const f=t+n+l;try{const m=await fetch(f);if(m.ok){const p=await m.text();switch(d){case"vertexShader":i=p;break;case"fragmentShader":c=p;break;case"geometryShader":a=p;break;case"tessControlShader":h=p;break;case"tessEvalShader":o=p;break}}}catch{}})),!i||!c)throw new Error("Le dossier ne contient pas de vertexShader (.vs) ou fragmentShader (.fs)");return console.log("Loaded shaders from folder",t),new lt(i,c,a,h,o)}static testShader(){const t=`#version 300 es
        precision highp float;

        in vec3 a_position;

        uniform mat4 u_proj;
        uniform mat4 u_view;
        uniform mat4 u_model;


        void main() {
            vec4 worldPos = u_model * vec4(a_position, 1.0);
            gl_Position = u_proj * u_view * worldPos;
        }
        `,e=`#version 300 es
        precision highp float;
        out vec4 outColor;
        void main() {
            outColor = vec4(1.0,0.0,0.0, 1.0);
        }
        `;return new lt(t,e)}}class xt{gl;program;uniformLocations=new Map;pendingUniforms=new Map;dirtyUniforms=new Set;uniformCache=new Map;attribBindings=new Map;constructor(t,e){this.gl=t;const s=this.compile(t.VERTEX_SHADER,e.vertexShader),n=this.compile(t.FRAGMENT_SHADER,e.fragmentShader),r=t.createProgram();if(!r)throw new Error("Impossible de créer le programme WebGL.");t.attachShader(r,s),t.attachShader(r,n);for(const[i,c]of this.attribBindings.entries())t.bindAttribLocation(r,c,i);if(t.linkProgram(r),!t.getProgramParameter(r,t.LINK_STATUS)){const i=t.getProgramInfoLog(r);throw new Error("Erreur de linkage du shader: "+i)}t.deleteShader(s),t.deleteShader(n),this.program=r}bindAttrib(t,e){this.attribBindings.set(t,e)}use(){this.gl.useProgram(this.program);for(const t of Array.from(this.dirtyUniforms)){const e=this.pendingUniforms.get(t);e!==void 0&&(this.applyUniform(t,e),this.pendingUniforms.delete(t)),this.dirtyUniforms.delete(t)}}getUniformLocation(t){if(this.uniformLocations.has(t))return this.uniformLocations.get(t);const e=this.gl.getUniformLocation(this.program,t);return e?(this.uniformLocations.set(t,e),e):(this.uniformLocations.set(t,null),null)}set(t,e){this.pendingUniforms.set(t,e),this.dirtyUniforms.add(t)}setUniform(t,e){this.applyUniform(t,e)}applyUniform(t,e){const s=this.getUniformLocation(t);if(!s)return;const n=this.uniformCache.get(t);if(n!==void 0){if(typeof n=="number"||typeof n=="boolean"){if(n===e)return}else if(Array.isArray(n)||n instanceof Float32Array||n instanceof Int32Array){const i=n.length;if((Array.isArray(e)||e instanceof Float32Array||e instanceof Int32Array)&&e.length===i){let c=!0;for(let a=0;a<i;a++)if(n[a]!==e[a]){c=!1;break}if(c)return}}}if(typeof e=="number"){this.gl.uniform1f(s,e),this.uniformCache.set(t,e);return}if(typeof e=="boolean"){this.gl.uniform1i(s,e?1:0),this.uniformCache.set(t,e);return}if(e instanceof Int32Array)switch(e.length){case 1:this.gl.uniform1iv(s,e),this.uniformCache.set(t,new Int32Array(e));return;case 2:this.gl.uniform2iv(s,e),this.uniformCache.set(t,new Int32Array(e));return;case 3:this.gl.uniform3iv(s,e),this.uniformCache.set(t,new Int32Array(e));return;case 4:this.gl.uniform4iv(s,e),this.uniformCache.set(t,new Int32Array(e));return}const r=Array.isArray(e)||e instanceof Float32Array?e.length:0;if(r>0&&(e instanceof Float32Array||Array.isArray(e)))switch(r){case 1:this.gl.uniform1fv(s,e),this.uniformCache.set(t,new Float32Array(e));return;case 2:this.gl.uniform2fv(s,e),this.uniformCache.set(t,new Float32Array(e));return;case 3:this.gl.uniform3fv(s,e),this.uniformCache.set(t,new Float32Array(e));return;case 4:this.gl.uniform4fv(s,e),this.uniformCache.set(t,new Float32Array(e));return;case 9:this.gl.uniformMatrix3fv(s,!1,e),this.uniformCache.set(t,new Float32Array(e));return;case 16:this.gl.uniformMatrix4fv(s,!1,e),this.uniformCache.set(t,new Float32Array(e));return;default:this.gl.uniform1fv(s,new Float32Array(e)),this.uniformCache.set(t,new Float32Array(e));return}console.warn(`Cannot set uniform '${t}' with value:`,e)}compile(t,e){const s=this.gl.createShader(t);if(!s)throw new Error("Cannot create shader.");if(this.gl.shaderSource(s,e),this.gl.compileShader(s),!this.gl.getShaderParameter(s,this.gl.COMPILE_STATUS)){const n=this.gl.getShaderInfoLog(s);throw new Error("Shader compilation error: "+n)}return s}delete(){this.gl.deleteProgram(this.program),this.uniformCache.clear(),this.uniformLocations.clear()}clearUniformCache(){this.uniformCache.clear()}getProgram(){return this.program}}class k{static currentGLContext=null;canvas;gl;constructor(t){this.canvas=t;const e=t.getContext("webgl2");if(e)console.log("WebGL2 context initialized",e);else throw new Error("WebGL2 non supporté par ce navigateur");this.gl=e,this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.BACK),this.gl.enable(this.gl.DEPTH_TEST),this.resizeCanvas(),window.addEventListener("resize",this.resizeCanvas.bind(this))}clear(t=0,e=0,s=0,n=1){this.gl.clearColor(t,e,s,n),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT)}setViewport(t,e){console.log("Set viewport",t,e),this.gl.viewport(0,0,t,e)}enableDepthTest(){this.gl.enable(this.gl.DEPTH_TEST)}resizeCanvas(){console.log("Resizing canvas to",window.innerWidth,window.innerHeight),this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight,this.setViewport(this.canvas.width,this.canvas.height)}getAspectRatio(){return this.canvas.width/this.canvas.height}static getGL(t){if(t)return t instanceof k?t.gl:t;if(k.currentGLContext)return k.currentGLContext.gl;throw new Error("No WebGL context available")}}class J{static texturePromises=new Map;static textureCache=new Map;static shaderCache=new Map;static async loadTexture(t,e){if(e=k.getGL(e),!e)throw new Error("No WebGL context available");if(this.textureCache.has(t))return this.textureCache.get(t);if(this.texturePromises.has(t))return this.texturePromises.get(t);const s=pt.loadTexture(e,t).then(n=>(n&&this.textureCache.set(t,n),this.texturePromises.delete(t),n));return this.texturePromises.set(t,s),s}static getTexture(t){return this.textureCache.get(t)}static loadTextureHandle(t,e){e=k.getGL(e);const s={state:"loading"},n=this.loadTexture(t,e).then(i=>(s.state="ready",s.texture=i??null,i)).catch(i=>{throw s.state="error",s.error=i,i}),r={ready:[],error:[]};return n.then(i=>{for(const c of r.ready)c(i??null)}).catch(i=>{for(const c of r.error)c(i)}),{stateObj:s,promise:n,onReady:i=>{r.ready.push(i),s.state==="ready"&&i(s.texture??null)},onError:i=>{r.error.push(i),s.state==="error"&&s.error&&i(s.error)}}}static async loadShaderProgram(t,e){if(e=k.getGL(e),this.shaderCache.has(t))return this.shaderCache.get(t);const s=await yt.LoadShaderFolder(t),n=new xt(e,s);return this.shaderCache.set(t,n),n}static getShaderProgram(t){return this.shaderCache.get(t)}static loadShaderProgramHandle(t,e){e=k.getGL(e);const s={state:"loading"},n=this.loadShaderProgram(t,e).then(i=>(s.state="ready",s.program=i,i)).catch(i=>{throw s.state="error",s.error=i,i}),r={ready:[],error:[]};return n.then(i=>{for(const c of r.ready)c(i)}).catch(i=>{for(const c of r.error)c(i)}),{stateObj:s,promise:n,onReady:i=>{r.ready.push(i),s.state==="ready"&&s.program&&i(s.program)},onError:i=>{r.error.push(i),s.state==="error"&&s.error&&i(s.error)}}}static clearTextures(){this.texturePromises.clear(),this.textureCache.clear()}static clearTexturesGL(t){t=k.getGL(t);for(const e of this.textureCache.values())t.deleteTexture(e);this.clearTextures()}static deleteTexture(t,e){e=k.getGL(e);const s=this.textureCache.get(t);s&&(e.deleteTexture(s),this.textureCache.delete(t))}static deleteShaderProgram(t){const e=this.shaderCache.get(t);e&&(e.delete(),this.shaderCache.delete(t))}}class K{shader;uniforms={};textures={};constructor(t){this.shader=t}setUniform(t,e){this.uniforms[t]=e}setTextureUniform(t,e){this.textures[t]=e}applyTo(t){t=k.getGL(t);for(const[s,n]of Object.entries(this.uniforms))this.shader.setUniform(s,n);let e=0;for(const[s,n]of Object.entries(this.textures)){const r=J.getTexture(n);r?(t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,r),this.shader.setUniform(s,e),e++):J.loadTexture(n,t).catch(i=>console.warn("Texture load failed",n,i))}}}class Mt{static getSignature(t){const e=t.shader?.getProgram?t.shader.getProgram().toString():"shader",s=Object.keys(t.uniforms).sort().join(","),n=Object.keys(t.textures).sort().join(",");return`${e}|u:${s}|t:${n}`}}class ft{modelGL;constructor(t){this.modelGL=t}getVAO(){return this.modelGL.vao}getVertexCount(){return this.modelGL.vertexCount}getIndexType(){return this.modelGL.indexType||0}dispose(t){try{this.modelGL&&typeof this.modelGL.delete=="function"&&this.modelGL.delete(t)}catch(e){console.warn("Error disposing ModelGL",e)}}}class _{position=new b(0,0,0);rotation=new L(0,0,0,1);scale=new b(1,1,1);constructor(){}setPosition(t){this.position=t}setRotationQuat(t){this.rotation=t}setRotationEuler(t){L.fromEuler(this.rotation,t.x,t.y,t.z)}setScale(t){this.scale=t}getPosition(){return this.position}getRotation(){return this.rotation}getRotationEuler(){return this.toEulerXYZ(this.rotation)}toEulerXYZ(t){const e=t.w*t.x,s=t.w*t.y,n=t.w*t.z,r=t.x*t.x,i=t.x*t.y,c=t.x*t.z,a=t.y*t.y,h=t.y*t.z,o=t.z*t.z;return new b(-Math.atan2(2*(h-e),1-2*(r+a))*180/Math.PI,Math.asin(2*(c+s))*180/Math.PI,-Math.atan2(2*(i-n),1-2*(a+o))*180/Math.PI)}getScale(){return this.scale}lookAt(t,e=new b(0,1,0)){const s=new b;b.subtract(s,t,this.position),b.normalize(s,s);const n=new v;v.targetTo(n,this.position,t,e);const r=new L;v.getRotation(r,n),this.rotation=r}getLocalMatrix(){const t=new v;return v.fromRotationTranslationScale(t,this.rotation,this.position,this.scale),t}getViewMatrix(){const t=new v,e=new L;L.invert(e,this.rotation);const s=new b;return b.negate(s,this.position),b.transformQuat(s,s,e),v.fromRotationTranslation(t,e,s),t}rotate(t,e){e==="x"&&(e=new b(1,0,0)),e==="y"&&(e=new b(0,1,0)),e==="z"&&(e=new b(0,0,1));const s=new L;L.setAxisAngle(s,e,t),L.multiply(this.rotation,s,this.rotation)}rotateX(t){this.rotate(t,new b(1,0,0))}rotateY(t){this.rotate(t,new b(0,1,0))}rotateZ(t){this.rotate(t,new b(0,0,1))}}class st{}class gt extends st{fn;constructor(t){super(),this.fn=t}update(t,e){this.fn(t,e)}}class wt{systems=[];add(t){typeof t=="function"?this.systems.push(new gt(t)):this.systems.push(t)}update(t,e){for(const s of this.systems)s.update(t,e)}}class At extends st{engine;constructor(t){super(),this.engine=t}update(t,e){if(!this.engine.scene)return;const s=this.engine.scene.getActiveCamera();if(!s)throw new Error("No active camera in the scene");this.engine.glContext.clear(58/255,22/255,81/255,1);const n=e.get(s,et),r=e.get(s,_),i=e.getAllOfType(ft),c=r.getViewMatrix(),a=n.getProjectionMatrix(this.engine.glContext.getAspectRatio()),h=new Map;for(const[l,d]of i){const f=e.get(l,_),m=e.get(l,K);if(!f||!m)continue;const p=Mt.getSignature(m);h.has(p)||h.set(p,[]),h.get(p).push([l,d])}const o=this.engine.glContext.gl;for(const[l,d]of h.entries()){const f=d[0][0],p=e.get(f,K).shader;p.use(),p.setUniform("u_proj",a),p.setUniform("u_view",c),p.setUniform("u_cameraPos",r.getPosition());for(const[y,M]of d){const x=e.get(y,_),g=e.get(y,K);if(p.setUniform("u_model",x.getLocalMatrix()),g.applyTo(o),M.getVAO()){o.bindVertexArray(M.getVAO());const w=M.getIndexType()||o.UNSIGNED_SHORT;o.drawElements(o.TRIANGLES,M.getVertexCount(),w,0),o.bindVertexArray(null)}}}}}class nt{glContext;scene=null;constructor(t){this.glContext=new k(t),k.currentGLContext=this.glContext}start(){let t=performance.now();const e=s=>{const n=(s-t)/1e3;t=s,this.scene&&this.scene.update(n),requestAnimationFrame(e)};requestAnimationFrame(e)}setScene(t){this.scene=t}static async StartEngine(t,e){console.log("Initializing Engine...");const s=new nt(t);return console.log("Initializing Scene..."),await e.initialize(),e.addSystem(new At(s)),console.log("Scene initialized..."),s.setScene(e),console.log("Start engine..."),s.start(),console.log("Engine started."),s}}class Tt{components=new Map;add(t,e){const s=e.constructor.name;this.components.has(s)||this.components.set(s,new Map),this.components.get(s).set(t,e)}remove(t,e){this.components.get(e.name)?.delete(t)}get(t,e){return this.components.get(e.name)?.get(t)}getAllOfType(t){const e=this.components.get(t.name);return e?Array.from(e.entries()):[]}getComponentsForEntity(t){const e=[];for(const[s,n]of this.components.entries()){const r=n.get(t);r&&e.push([s,r])}return e}removeAllComponents(t){for(const e of this.components.values())e.delete(t)}}class Et{type;color;intensity;constructor(t="point",e=new b(1,1,1),s=1){this.type=t,this.color=e,this.intensity=s}}class bt{nextId=0;entities=new Set;constructor(){}create(){const t=this.nextId++;return this.entities.add(t),t}destroy(t){this.entities.delete(t)}getAll(){return Array.from(this.entities)}}class Rt{entities;components;systems;constructor(){this.entities=new bt,this.components=new Tt,this.systems=new wt}createEntity(){const t=this.entities.create();return this.components.add(t,new _),t}createCamera(){const t=this.createEntity();return this.components.add(t,new et),t}createLight(t){const e=this.createEntity();return this.components.add(e,new Et(t)),e}createMesh(t,e=null){const s=this.createEntity();return this.components.add(s,new ft(t)),e!=null&&this.components.add(s,e),s}}class Y{vao;vertexCount;indexType;constructor(t,e,s=0){this.vao=t,this.vertexCount=e,this.indexType=s}delete(t){t=k.getGL(t),t&&this.vao&&t.deleteVertexArray(this.vao)}static generate(t,e,s,n,r){r=k.getGL(r);const i=r.createVertexArray();r.bindVertexArray(i);const c=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,c),r.bufferData(r.ARRAY_BUFFER,new Float32Array(t),r.STATIC_DRAW);const a=0;r.enableVertexAttribArray(a),r.vertexAttribPointer(a,3,r.FLOAT,!1,0,0);let h=null;if(s&&s.length>0){h=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,h),r.bufferData(r.ARRAY_BUFFER,new Float32Array(s),r.STATIC_DRAW);const f=1;r.enableVertexAttribArray(f),r.vertexAttribPointer(f,3,r.FLOAT,!1,0,0)}let o=null;if(n&&n.length>0){o=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,o),r.bufferData(r.ARRAY_BUFFER,new Float32Array(n),r.STATIC_DRAW);const f=2;r.enableVertexAttribArray(f),r.vertexAttribPointer(f,2,r.FLOAT,!1,0,0)}const l=r.createBuffer();r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,l);let d=r.UNSIGNED_SHORT;return e.length>65535?(r.bufferData(r.ELEMENT_ARRAY_BUFFER,new Uint32Array(e),r.STATIC_DRAW),d=r.UNSIGNED_INT):(r.bufferData(r.ELEMENT_ARRAY_BUFFER,new Uint16Array(e),r.STATIC_DRAW),d=r.UNSIGNED_SHORT),r.bindVertexArray(null),new Y(i,e.length,d)}static createFromProgram(t,e,s,n,r,i){i=k.getGL(i);const c=i.createVertexArray();i.bindVertexArray(c);const a=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,a),i.bufferData(i.ARRAY_BUFFER,new Float32Array(e),i.STATIC_DRAW);const h=i.getAttribLocation(t,"a_position");if(h>=0&&(i.enableVertexAttribArray(h),i.vertexAttribPointer(h,3,i.FLOAT,!1,0,0)),n&&n.length>0){const d=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,d),i.bufferData(i.ARRAY_BUFFER,new Float32Array(n),i.STATIC_DRAW);const f=i.getAttribLocation(t,"a_normal");f>=0&&(i.enableVertexAttribArray(f),i.vertexAttribPointer(f,3,i.FLOAT,!1,0,0))}if(r&&r.length>0){const d=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,d),i.bufferData(i.ARRAY_BUFFER,new Float32Array(r),i.STATIC_DRAW);const f=i.getAttribLocation(t,"a_uv");f>=0&&(i.enableVertexAttribArray(f),i.vertexAttribPointer(f,2,i.FLOAT,!1,0,0))}const o=i.createBuffer();i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,o);let l=i.UNSIGNED_SHORT;return s.length>65535?(i.bufferData(i.ELEMENT_ARRAY_BUFFER,new Uint32Array(s),i.STATIC_DRAW),l=i.UNSIGNED_INT):(i.bufferData(i.ELEMENT_ARRAY_BUFFER,new Uint16Array(s),i.STATIC_DRAW),l=i.UNSIGNED_SHORT),i.bindVertexArray(null),new Y(c,s.length,l)}}class zt{static generateCube(t,e){const s=t/2,n=[-s,-s,-s,s,-s,-s,s,s,-s,-s,s,-s,-s,-s,s,s,-s,s,s,s,s,-s,s,s],r=[-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1],i=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1],c=[0,2,1,0,3,2,4,5,6,4,6,7,4,3,0,4,7,3,1,6,5,1,2,6,3,6,2,3,7,6,4,1,5,4,0,1];return Y.generate(n,c,r,i,e)}static generateCubeForProgram(t,e,s){const n=e/2,r=[-n,-n,-n,n,-n,-n,n,n,-n,-n,n,-n,-n,-n,n,n,-n,n,n,n,n,-n,n,n],i=[-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1],c=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1],a=[0,2,1,0,3,2,4,5,6,4,6,7,4,3,0,4,7,3,1,6,5,1,2,6,3,6,2,3,7,6,4,1,5,4,0,1];return Y.createFromProgram(t,r,a,i,c,s)}static generateCube24Vertex(t,e){const s=t/2,n=[-s,-s,s,s,-s,s,s,s,s,-s,s,s,-s,-s,-s,-s,s,-s,s,s,-s,s,-s,-s,-s,-s,-s,-s,-s,s,-s,s,s,-s,s,-s,s,-s,-s,s,s,-s,s,s,s,s,-s,s,-s,s,-s,-s,s,s,s,s,s,s,s,-s,-s,-s,-s,s,-s,-s,s,-s,s,-s,-s,s],r=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],i=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1],c=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];return Y.generate(n,c,r,i,e)}static generateTriangle(t){const e=[-.5,.5,0,-.5,-.5,0,.5,-.5,0],s=[0,0,1,0,0,1,0,0,1],n=[0,1,0,0,1,0],r=[0,1,2];return Y.generate(e,r,s,n,t)}}class Lt{static async LoadFromURL(t,e=!0,s){const n=t.split(".").pop()?.toLowerCase();if(n!="obj"&&n!="gltf"&&n!="glb")return console.error("Unsupported model format for URL: "+t),null;let r=null;const i=await V.loadResource(t);if(!i)return console.error("Failed to load model from URL: "+t),null;switch(n){case"obj":r=await this.LoadOBJ(V.loadedResourceToText(i),t,s);break;case"gltf":r=this.loadGLTF(V.loadedResourceToText(i),s);break;case"glb":break;default:console.error("Loading not implemented for URL: "+t)}return r}static async LoadOBJ(t,e,s){let n=null,r=null;e&&(n=V.loadedResourceToText(await V.loadResource(e.replace(".obj",".mtl"))));const i=t.split(/\r?\n/),c=[],a=[],h=[],o=[],l=[],d=[],f=[],m=new Map;function p(M,x){const g=parseInt(M,10);return isNaN(g)?-1:g<0?x+g:g-1}for(let M of i){const x=M.trim();if(!x||x.startsWith("#"))continue;const g=x.split(/\s+/),w=g[0];if(w==="v")g.length>=4&&c.push(parseFloat(g[1]),parseFloat(g[2]),parseFloat(g[3]));else if(w==="vn")g.length>=4&&a.push(parseFloat(g[1]),parseFloat(g[2]),parseFloat(g[3]));else if(w==="vt")g.length>=3&&h.push(parseFloat(g[1]),parseFloat(g[2]));else if(w==="f"){const A=g.slice(1);if(A.length<3)continue;const T=[];for(const E of A){const S=E.split("/"),R=p(S[0],c.length/3),U=S.length>1&&S[1]!==""?p(S[1],h.length/2):null,z=S.length>2&&S[2]!==""?p(S[2],a.length/3):null;T.push({v:R,vt:U,vn:z})}for(let E=1;E<T.length-1;E++){const S=[T[0],T[E],T[E+1]];for(const R of S){const U=`${R.v}/${R.vt!==null?R.vt:""}/${R.vn!==null?R.vn:""}`;let z=m.get(U);z===void 0&&(z=o.length/3,m.set(U,z),R.v>=0&&R.v*3+2<c.length?o.push(c[R.v*3+0],c[R.v*3+1],c[R.v*3+2]):o.push(0,0,0),R.vt!==null&&R.vt>=0&&R.vt*2+1<h.length?d.push(h[R.vt*2+0],h[R.vt*2+1]):d.push(0,0),R.vn!==null&&R.vn>=0&&R.vn*3+2<a.length?l.push(a[R.vn*3+0],a[R.vn*3+1],a[R.vn*3+2]):l.push(0,0,0)),f.push(z)}}}}if(a.length===0&&(l.length=0),h.length===0&&(d.length=0),n){const M=n.split(/\r?\n/);let x=null;for(let g of M){const w=g.trim();if(!w||w.startsWith("#"))continue;const A=w.split(/\s+/),T=A[0];if(T==="newmtl"){if(x)break;x={name:A[1]}}else T==="Kd"&&x?x.Kd=[parseFloat(A[1])||0,parseFloat(A[2])||0,parseFloat(A[3])||0]:(T==="map_Kd"||T==="map_kd")&&x&&(x.map_Kd=A.slice(1).join(" "))}x&&console.info("MTL parsed (first material):",x)}if(a.length===0){const M=o.length/3,x=new Array(M*3).fill(0);for(let g=0;g<f.length;g+=3){const w=f[g+0],A=f[g+1],T=f[g+2],E=o[w*3+0],S=o[w*3+1],R=o[w*3+2],U=o[A*3+0],z=o[A*3+1],N=o[A*3+2],I=o[T*3+0],D=o[T*3+1],F=o[T*3+2],q=U-E,X=z-S,W=N-R,$=I-E,H=D-S,rt=F-R,Q=X*rt-W*H,u=W*$-q*rt,tt=q*H-X*$;x[w*3+0]+=Q,x[w*3+1]+=u,x[w*3+2]+=tt,x[A*3+0]+=Q,x[A*3+1]+=u,x[A*3+2]+=tt,x[T*3+0]+=Q,x[T*3+1]+=u,x[T*3+2]+=tt}for(let g=0;g<o.length;g+=3){const w=x[g+0],A=x[g+1],T=x[g+2],E=Math.sqrt(w*w+A*A+T*T)||1;l[g+0]=w/E,l[g+1]=A/E,l[g+2]=T/E}}let y=null;if(n){const M=n.split(/\r?\n/);let x=null;for(let g of M){const w=g.trim();if(!w||w.startsWith("#"))continue;const A=w.split(/\s+/),T=A[0];if(T==="newmtl"){if(x)break;x={name:A[1]}}else T==="Kd"&&x?x.Kd=[parseFloat(A[1])||0,parseFloat(A[2])||0,parseFloat(A[3])||0]:(T==="map_Kd"||T==="map_kd")&&x&&(x.map_Kd=A.slice(1).join(" "))}y=x}try{const M=Y.generate(o,f,l.length>0?l:void 0,d.length>0?d:void 0,s);if(y&&e)try{const x=await J.loadShaderProgram("/assets/shaders/pbr",k.getGL(s)),g=new K(x);if(y.Kd&&(x.set("u_albedo",new Float32Array(y.Kd)),x.set("u_useAlbedoMap",0),g.setUniform("u_albedo",new Float32Array(y.Kd))),y.map_Kd){let w=y.map_Kd;try{const A=new URL(e,window.location.href);w=new URL(w,A).toString()}catch{}g.setTextureUniform("u_albedoMap",w),g.setUniform("u_useAlbedoMap",1)}r=g}catch(x){console.warn("Failed to create Material from MTL",x)}return{model:M,material:r}}catch(M){return console.error("Failed to create ModelGL from OBJ data",M),null}}static loadGLTF(t,e){let s=null;const n=[],r=[],i=[],c=[];return{model:Y.generate(n,c,r,i,e),material:s}}}class St{ecs;name;active;activeCamera=null;constructor(t="Untitled"){this.name=t,this.active=!0,this.ecs=new Rt}runtimeInitializer=null;async onInitialize(){}async initialize(){this.active&&(this.runtimeInitializer&&await this.runtimeInitializer(this),await this.onInitialize())}setInitializer(t){this.runtimeInitializer=t}update(t){this.active&&this.ecs.systems.update(t,this.ecs.components)}createCamera(){const t=this.ecs.createCamera();return this.activeCamera===null&&(this.activeCamera=t),t}setActiveCamera(t){if(!this.ecs.components.get(t,et))throw new Error("L'entité donnée n'a pas de composant Camera");this.activeCamera=t}getActiveCamera(){return this.activeCamera}createEntity(){return this.ecs.createEntity()}createLight(t){return this.ecs.createLight(t)}createMesh(t,e=null){let s;return t instanceof Y?s=t:(s=t.model,!e&&t.material&&(e=t.material)),this.ecs.createMesh(s,e)}async createMeshFromURL(t,e){console.log("Loading model from URL:",t);const s=await Lt.LoadFromURL(t,!e);return console.log("Model exist :",s!=null),s==null?null:this.createMesh(s,e)}destroyEntity(t,e){t===this.activeCamera&&(this.activeCamera=null),this.ecs.components.getAllOfType(Object);try{for(const[s,n]of this.ecs.components.components.entries()){const r=n.get(t);if(r&&typeof r.dispose=="function")try{r.dispose(e?.glContext?.gl)}catch(i){console.warn("dispose failed for",s,i)}}}catch{}this.ecs.components.removeAllComponents(t),this.ecs.entities.destroy(t)}getComponent(t,e){return this.ecs.components.get(t,e)}getAllComponentOfType(t){return this.ecs.components.getAllOfType(t)}addSystem(t){this.ecs.systems.add(t)}}class Ft extends st{mainEntity;targetEntity;radius;azimuth;elevation;speed;constructor(t,e,s=5,n=0,r=0,i=30){super(),this.mainEntity=t,this.targetEntity=e,this.radius=s,this.azimuth=n,this.elevation=r,this.speed=i}update(t,e){this.azimuth+=this.speed*t,this.azimuth>360&&(this.azimuth-=360),this.azimuth<0&&(this.azimuth+=360);const s=e.get(this.mainEntity,_),n=e.get(this.targetEntity,_);if(!s||!n)return;const r=n.getPosition(),i=this.azimuth*Math.PI/180,c=this.elevation*Math.PI/180,a=r.x+this.radius*Math.cos(c)*Math.cos(i),h=r.y+this.radius*Math.sin(c),o=r.z+this.radius*Math.cos(c)*Math.sin(i);s.setPosition(new b(a,h,o)),s.lookAt(r)}}class Ct extends St{async onInitialize(){const t=await J.loadShaderProgram("/assets/shaders/pbr"),e=await this.createMeshFromURL("/assets/models/backpack/backpack.obj");this.getComponent(e,_).setPosition(new b(0,0,0));const n=this.createMesh(zt.generateCubeForProgram(t.getProgram(),1.5),new K(t));this.getComponent(n,_).setPosition(new b(0,-4,0));const i=this.createCamera();this.setActiveCamera(i);const c=this.getComponent(i,_);c.setPosition(new b(2,2,2)),c.lookAt(new b(0,0,0)),this.addSystem(new Ft(i,e,10,5,2,20))}}let vt=document.querySelector("#glCanvas");nt.StartEngine(vt,new Ct);
