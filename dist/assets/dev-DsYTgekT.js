(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))e(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const c of r.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&e(c)}).observe(document,{childList:!0,subtree:!0});function s(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function e(n){if(n.ep)return;n.ep=!0;const r=s(n);fetch(n.href,r)}})();class rt{components=new Map;add(t,s){const e=s.constructor.name;this.components.has(e)||this.components.set(e,new Map),this.components.get(e).set(t,s)}remove(t,s){this.components.get(s.name)?.delete(t)}get(t,s){return this.components.get(s.name)?.get(t)}getAllOfType(t){const s=this.components.get(t.name);return s?Array.from(s.entries()):[]}}const C=1e-6,K=new Float32Array([1,0,0,0,1,0,0,0,1]);class B extends Float32Array{static BYTE_LENGTH=9*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 9:super(t);break;case 2:super(t[0],t[1],9);break;case 1:const s=t[0];typeof s=="number"?super([s,s,s,s,s,s,s,s,s]):super(s,0,9);break;default:super(K);break}}get str(){return B.str(this)}copy(t){return this.set(t),this}identity(){return this.set(K),this}multiply(t){return B.multiply(this,this,t)}mul(t){return this}transpose(){return B.transpose(this,this)}invert(){return B.invert(this,this)}translate(t){return B.translate(this,this,t)}rotate(t){return B.rotate(this,this,t)}scale(t){return B.scale(this,this,t)}static create(){return new B}static clone(t){return new B(t)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t}static fromValues(...t){return new B(...t)}static set(t,...s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t}static identity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}static transpose(t,s){if(t===s){const e=s[1],n=s[2],r=s[5];t[1]=s[3],t[2]=s[6],t[3]=e,t[5]=s[7],t[6]=n,t[7]=r}else t[0]=s[0],t[1]=s[3],t[2]=s[6],t[3]=s[1],t[4]=s[4],t[5]=s[7],t[6]=s[2],t[7]=s[5],t[8]=s[8];return t}static invert(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8],d=o*i-a*l,M=-o*c+a*h,m=l*c-i*h;let p=e*d+n*M+r*m;return p?(p=1/p,t[0]=d*p,t[1]=(-o*n+r*l)*p,t[2]=(a*n-r*i)*p,t[3]=M*p,t[4]=(o*e-r*h)*p,t[5]=(-a*e+r*c)*p,t[6]=m*p,t[7]=(-l*e+n*h)*p,t[8]=(i*e-n*c)*p,t):null}static adjoint(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8];return t[0]=i*o-a*l,t[1]=r*l-n*o,t[2]=n*a-r*i,t[3]=a*h-c*o,t[4]=e*o-r*h,t[5]=r*c-e*a,t[6]=c*l-i*h,t[7]=n*h-e*l,t[8]=e*i-n*c,t}static determinant(t){const s=t[0],e=t[1],n=t[2],r=t[3],c=t[4],i=t[5],a=t[6],h=t[7],l=t[8];return s*(l*c-i*h)+e*(-l*r+i*a)+n*(h*r-c*a)}static add(t,s,e){return t[0]=s[0]+e[0],t[1]=s[1]+e[1],t[2]=s[2]+e[2],t[3]=s[3]+e[3],t[4]=s[4]+e[4],t[5]=s[5]+e[5],t[6]=s[6]+e[6],t[7]=s[7]+e[7],t[8]=s[8]+e[8],t}static subtract(t,s,e){return t[0]=s[0]-e[0],t[1]=s[1]-e[1],t[2]=s[2]-e[2],t[3]=s[3]-e[3],t[4]=s[4]-e[4],t[5]=s[5]-e[5],t[6]=s[6]-e[6],t[7]=s[7]-e[7],t[8]=s[8]-e[8],t}static sub(t,s,e){return t}static multiply(t,s,e){const n=s[0],r=s[1],c=s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7],d=s[8];let M=e[0],m=e[1],p=e[2];return t[0]=M*n+m*i+p*l,t[1]=M*r+m*a+p*o,t[2]=M*c+m*h+p*d,M=e[3],m=e[4],p=e[5],t[3]=M*n+m*i+p*l,t[4]=M*r+m*a+p*o,t[5]=M*c+m*h+p*d,M=e[6],m=e[7],p=e[8],t[6]=M*n+m*i+p*l,t[7]=M*r+m*a+p*o,t[8]=M*c+m*h+p*d,t}static mul(t,s,e){return t}static translate(t,s,e){const n=s[0],r=s[1],c=s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7],d=s[8],M=e[0],m=e[1];return t[0]=n,t[1]=r,t[2]=c,t[3]=i,t[4]=a,t[5]=h,t[6]=M*n+m*i+l,t[7]=M*r+m*a+o,t[8]=M*c+m*h+d,t}static rotate(t,s,e){const n=s[0],r=s[1],c=s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7],d=s[8],M=Math.sin(e),m=Math.cos(e);return t[0]=m*n+M*i,t[1]=m*r+M*a,t[2]=m*c+M*h,t[3]=m*i-M*n,t[4]=m*a-M*r,t[5]=m*h-M*c,t[6]=l,t[7]=o,t[8]=d,t}static scale(t,s,e){const n=e[0],r=e[1];return t[0]=n*s[0],t[1]=n*s[1],t[2]=n*s[2],t[3]=r*s[3],t[4]=r*s[4],t[5]=r*s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t}static fromTranslation(t,s){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=s[0],t[7]=s[1],t[8]=1,t}static fromRotation(t,s){const e=Math.sin(s),n=Math.cos(s);return t[0]=n,t[1]=e,t[2]=0,t[3]=-e,t[4]=n,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}static fromScaling(t,s){return t[0]=s[0],t[1]=0,t[2]=0,t[3]=0,t[4]=s[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}static fromMat2d(t,s){return t[0]=s[0],t[1]=s[1],t[2]=0,t[3]=s[2],t[4]=s[3],t[5]=0,t[6]=s[4],t[7]=s[5],t[8]=1,t}static fromQuat(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=e+e,a=n+n,h=r+r,l=e*i,o=n*i,d=n*a,M=r*i,m=r*a,p=r*h,y=c*i,f=c*a,g=c*h;return t[0]=1-d-p,t[3]=o-g,t[6]=M+f,t[1]=o+g,t[4]=1-l-p,t[7]=m-y,t[2]=M-f,t[5]=m+y,t[8]=1-l-d,t}static fromMat4(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[4],t[4]=s[5],t[5]=s[6],t[6]=s[8],t[7]=s[9],t[8]=s[10],t}static normalFromMat4(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8],d=s[9],M=s[10],m=s[11],p=s[12],y=s[13],f=s[14],g=s[15],S=e*a-n*i,x=e*h-r*i,w=e*l-c*i,A=n*h-r*a,z=n*l-c*a,P=r*l-c*h,F=o*y-d*p,q=o*f-M*p,T=o*g-m*p,I=d*f-M*y,U=d*g-m*y,D=M*g-m*f;let v=S*D-x*U+w*I+A*T-z*q+P*F;return v?(v=1/v,t[0]=(a*D-h*U+l*I)*v,t[1]=(h*T-i*D-l*q)*v,t[2]=(i*U-a*T+l*F)*v,t[3]=(r*U-n*D-c*I)*v,t[4]=(e*D-r*T+c*q)*v,t[5]=(n*T-e*U-c*F)*v,t[6]=(y*P-f*z+g*A)*v,t[7]=(f*w-p*P-g*x)*v,t[8]=(p*z-y*w+g*S)*v,t):null}static projection(t,s,e){return t[0]=2/s,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/e,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t}static frob(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]+t[4]*t[4]+t[5]*t[5]+t[6]*t[6]+t[7]*t[7]+t[8]*t[8])}static multiplyScalar(t,s,e){return t[0]=s[0]*e,t[1]=s[1]*e,t[2]=s[2]*e,t[3]=s[3]*e,t[4]=s[4]*e,t[5]=s[5]*e,t[6]=s[6]*e,t[7]=s[7]*e,t[8]=s[8]*e,t}static multiplyScalarAndAdd(t,s,e,n){return t[0]=s[0]+e[0]*n,t[1]=s[1]+e[1]*n,t[2]=s[2]+e[2]*n,t[3]=s[3]+e[3]*n,t[4]=s[4]+e[4]*n,t[5]=s[5]+e[5]*n,t[6]=s[6]+e[6]*n,t[7]=s[7]+e[7]*n,t[8]=s[8]+e[8]*n,t}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]&&t[3]===s[3]&&t[4]===s[4]&&t[5]===s[5]&&t[6]===s[6]&&t[7]===s[7]&&t[8]===s[8]}static equals(t,s){const e=t[0],n=t[1],r=t[2],c=t[3],i=t[4],a=t[5],h=t[6],l=t[7],o=t[8],d=s[0],M=s[1],m=s[2],p=s[3],y=s[4],f=s[5],g=s[6],S=s[7],x=s[8];return Math.abs(e-d)<=C*Math.max(1,Math.abs(e),Math.abs(d))&&Math.abs(n-M)<=C*Math.max(1,Math.abs(n),Math.abs(M))&&Math.abs(r-m)<=C*Math.max(1,Math.abs(r),Math.abs(m))&&Math.abs(c-p)<=C*Math.max(1,Math.abs(c),Math.abs(p))&&Math.abs(i-y)<=C*Math.max(1,Math.abs(i),Math.abs(y))&&Math.abs(a-f)<=C*Math.max(1,Math.abs(a),Math.abs(f))&&Math.abs(h-g)<=C*Math.max(1,Math.abs(h),Math.abs(g))&&Math.abs(l-S)<=C*Math.max(1,Math.abs(l),Math.abs(S))&&Math.abs(o-x)<=C*Math.max(1,Math.abs(o),Math.abs(x))}static str(t){return`Mat3(${t.join(", ")})`}}B.prototype.mul=B.prototype.multiply;B.mul=B.multiply;B.sub=B.subtract;class E extends Float32Array{static BYTE_LENGTH=3*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 3:super(t);break;case 2:super(t[0],t[1],3);break;case 1:{const s=t[0];typeof s=="number"?super([s,s,s]):super(s,0,3);break}default:super(3);break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get b(){return this[2]}set b(t){this[2]=t}get magnitude(){const t=this[0],s=this[1],e=this[2];return Math.sqrt(t*t+s*s+e*e)}get mag(){return this.magnitude}get squaredMagnitude(){const t=this[0],s=this[1],e=this[2];return t*t+s*s+e*e}get sqrMag(){return this.squaredMagnitude}get str(){return E.str(this)}copy(t){return this.set(t),this}add(t){return this[0]+=t[0],this[1]+=t[1],this[2]+=t[2],this}subtract(t){return this[0]-=t[0],this[1]-=t[1],this[2]-=t[2],this}sub(t){return this}multiply(t){return this[0]*=t[0],this[1]*=t[1],this[2]*=t[2],this}mul(t){return this}divide(t){return this[0]/=t[0],this[1]/=t[1],this[2]/=t[2],this}div(t){return this}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this}scaleAndAdd(t,s){return this[0]+=t[0]*s,this[1]+=t[1]*s,this[2]+=t[2]*s,this}distance(t){return E.distance(this,t)}dist(t){return 0}squaredDistance(t){return E.squaredDistance(this,t)}sqrDist(t){return 0}negate(){return this[0]*=-1,this[1]*=-1,this[2]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this}dot(t){return this[0]*t[0]+this[1]*t[1]+this[2]*t[2]}normalize(){return E.normalize(this,this)}static create(){return new E}static clone(t){return new E(t)}static magnitude(t){let s=t[0],e=t[1],n=t[2];return Math.sqrt(s*s+e*e+n*n)}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static fromValues(t,s,e){return new E(t,s,e)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t}static set(t,s,e,n){return t[0]=s,t[1]=e,t[2]=n,t}static add(t,s,e){return t[0]=s[0]+e[0],t[1]=s[1]+e[1],t[2]=s[2]+e[2],t}static subtract(t,s,e){return t[0]=s[0]-e[0],t[1]=s[1]-e[1],t[2]=s[2]-e[2],t}static sub(t,s,e){return[0,0,0]}static multiply(t,s,e){return t[0]=s[0]*e[0],t[1]=s[1]*e[1],t[2]=s[2]*e[2],t}static mul(t,s,e){return[0,0,0]}static divide(t,s,e){return t[0]=s[0]/e[0],t[1]=s[1]/e[1],t[2]=s[2]/e[2],t}static div(t,s,e){return[0,0,0]}static ceil(t,s){return t[0]=Math.ceil(s[0]),t[1]=Math.ceil(s[1]),t[2]=Math.ceil(s[2]),t}static floor(t,s){return t[0]=Math.floor(s[0]),t[1]=Math.floor(s[1]),t[2]=Math.floor(s[2]),t}static min(t,s,e){return t[0]=Math.min(s[0],e[0]),t[1]=Math.min(s[1],e[1]),t[2]=Math.min(s[2],e[2]),t}static max(t,s,e){return t[0]=Math.max(s[0],e[0]),t[1]=Math.max(s[1],e[1]),t[2]=Math.max(s[2],e[2]),t}static scale(t,s,e){return t[0]=s[0]*e,t[1]=s[1]*e,t[2]=s[2]*e,t}static scaleAndAdd(t,s,e,n){return t[0]=s[0]+e[0]*n,t[1]=s[1]+e[1]*n,t[2]=s[2]+e[2]*n,t}static distance(t,s){const e=s[0]-t[0],n=s[1]-t[1],r=s[2]-t[2];return Math.sqrt(e*e+n*n+r*r)}static dist(t,s){return 0}static squaredDistance(t,s){const e=s[0]-t[0],n=s[1]-t[1],r=s[2]-t[2];return e*e+n*n+r*r}static sqrDist(t,s){return 0}static squaredLength(t){const s=t[0],e=t[1],n=t[2];return s*s+e*e+n*n}static sqrLen(t,s){return 0}static negate(t,s){return t[0]=-s[0],t[1]=-s[1],t[2]=-s[2],t}static inverse(t,s){return t[0]=1/s[0],t[1]=1/s[1],t[2]=1/s[2],t}static normalize(t,s){const e=s[0],n=s[1],r=s[2];let c=e*e+n*n+r*r;return c>0&&(c=1/Math.sqrt(c)),t[0]=s[0]*c,t[1]=s[1]*c,t[2]=s[2]*c,t}static dot(t,s){return t[0]*s[0]+t[1]*s[1]+t[2]*s[2]}static cross(t,s,e){const n=s[0],r=s[1],c=s[2],i=e[0],a=e[1],h=e[2];return t[0]=r*h-c*a,t[1]=c*i-n*h,t[2]=n*a-r*i,t}static lerp(t,s,e,n){const r=s[0],c=s[1],i=s[2];return t[0]=r+n*(e[0]-r),t[1]=c+n*(e[1]-c),t[2]=i+n*(e[2]-i),t}static slerp(t,s,e,n){const r=Math.acos(Math.min(Math.max(E.dot(s,e),-1),1)),c=Math.sin(r),i=Math.sin((1-n)*r)/c,a=Math.sin(n*r)/c;return t[0]=i*s[0]+a*e[0],t[1]=i*s[1]+a*e[1],t[2]=i*s[2]+a*e[2],t}static hermite(t,s,e,n,r,c){const i=c*c,a=i*(2*c-3)+1,h=i*(c-2)+c,l=i*(c-1),o=i*(3-2*c);return t[0]=s[0]*a+e[0]*h+n[0]*l+r[0]*o,t[1]=s[1]*a+e[1]*h+n[1]*l+r[1]*o,t[2]=s[2]*a+e[2]*h+n[2]*l+r[2]*o,t}static bezier(t,s,e,n,r,c){const i=1-c,a=i*i,h=c*c,l=a*i,o=3*c*a,d=3*h*i,M=h*c;return t[0]=s[0]*l+e[0]*o+n[0]*d+r[0]*M,t[1]=s[1]*l+e[1]*o+n[1]*d+r[1]*M,t[2]=s[2]*l+e[2]*o+n[2]*d+r[2]*M,t}static transformMat4(t,s,e){const n=s[0],r=s[1],c=s[2],i=e[3]*n+e[7]*r+e[11]*c+e[15]||1;return t[0]=(e[0]*n+e[4]*r+e[8]*c+e[12])/i,t[1]=(e[1]*n+e[5]*r+e[9]*c+e[13])/i,t[2]=(e[2]*n+e[6]*r+e[10]*c+e[14])/i,t}static transformMat3(t,s,e){let n=s[0],r=s[1],c=s[2];return t[0]=n*e[0]+r*e[3]+c*e[6],t[1]=n*e[1]+r*e[4]+c*e[7],t[2]=n*e[2]+r*e[5]+c*e[8],t}static transformQuat(t,s,e){const n=e[0],r=e[1],c=e[2],i=e[3]*2,a=s[0],h=s[1],l=s[2],o=r*l-c*h,d=c*a-n*l,M=n*h-r*a,m=(r*M-c*d)*2,p=(c*o-n*M)*2,y=(n*d-r*o)*2;return t[0]=a+o*i+m,t[1]=h+d*i+p,t[2]=l+M*i+y,t}static rotateX(t,s,e,n){const r=e[1],c=e[2],i=s[1]-r,a=s[2]-c;return t[0]=s[0],t[1]=i*Math.cos(n)-a*Math.sin(n)+r,t[2]=i*Math.sin(n)+a*Math.cos(n)+c,t}static rotateY(t,s,e,n){const r=e[0],c=e[2],i=s[0]-r,a=s[2]-c;return t[0]=a*Math.sin(n)+i*Math.cos(n)+r,t[1]=s[1],t[2]=a*Math.cos(n)-i*Math.sin(n)+c,t}static rotateZ(t,s,e,n){const r=e[0],c=e[1],i=s[0]-r,a=s[1]-c;return t[0]=i*Math.cos(n)-a*Math.sin(n)+r,t[1]=i*Math.sin(n)+a*Math.cos(n)+c,t[2]=e[2],t}static angle(t,s){const e=t[0],n=t[1],r=t[2],c=s[0],i=s[1],a=s[2],h=Math.sqrt((e*e+n*n+r*r)*(c*c+i*i+a*a)),l=h&&E.dot(t,s)/h;return Math.acos(Math.min(Math.max(l,-1),1))}static zero(t){return t[0]=0,t[1]=0,t[2]=0,t}static str(t){return`Vec3(${t.join(", ")})`}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]}static equals(t,s){const e=t[0],n=t[1],r=t[2],c=s[0],i=s[1],a=s[2];return Math.abs(e-c)<=C*Math.max(1,Math.abs(e),Math.abs(c))&&Math.abs(n-i)<=C*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-a)<=C*Math.max(1,Math.abs(r),Math.abs(a))}}E.prototype.sub=E.prototype.subtract;E.prototype.mul=E.prototype.multiply;E.prototype.div=E.prototype.divide;E.prototype.dist=E.prototype.distance;E.prototype.sqrDist=E.prototype.squaredDistance;E.sub=E.subtract;E.mul=E.multiply;E.div=E.divide;E.dist=E.distance;E.sqrDist=E.squaredDistance;E.sqrLen=E.squaredLength;E.mag=E.magnitude;E.length=E.magnitude;E.len=E.magnitude;const J=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);class R extends Float32Array{static BYTE_LENGTH=16*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 16:super(t);break;case 2:super(t[0],t[1],16);break;case 1:const s=t[0];typeof s=="number"?super([s,s,s,s,s,s,s,s,s,s,s,s,s,s,s,s]):super(s,0,16);break;default:super(J);break}}get str(){return R.str(this)}copy(t){return this.set(t),this}identity(){return this.set(J),this}multiply(t){return R.multiply(this,this,t)}mul(t){return this}transpose(){return R.transpose(this,this)}invert(){return R.invert(this,this)}translate(t){return R.translate(this,this,t)}rotate(t,s){return R.rotate(this,this,t,s)}scale(t){return R.scale(this,this,t)}rotateX(t){return R.rotateX(this,this,t)}rotateY(t){return R.rotateY(this,this,t)}rotateZ(t){return R.rotateZ(this,this,t)}perspectiveNO(t,s,e,n){return R.perspectiveNO(this,t,s,e,n)}perspectiveZO(t,s,e,n){return R.perspectiveZO(this,t,s,e,n)}orthoNO(t,s,e,n,r,c){return R.orthoNO(this,t,s,e,n,r,c)}orthoZO(t,s,e,n,r,c){return R.orthoZO(this,t,s,e,n,r,c)}static create(){return new R}static clone(t){return new R(t)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],t}static fromValues(...t){return new R(...t)}static set(t,...s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],t}static identity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static transpose(t,s){if(t===s){const e=s[1],n=s[2],r=s[3],c=s[6],i=s[7],a=s[11];t[1]=s[4],t[2]=s[8],t[3]=s[12],t[4]=e,t[6]=s[9],t[7]=s[13],t[8]=n,t[9]=c,t[11]=s[14],t[12]=r,t[13]=i,t[14]=a}else t[0]=s[0],t[1]=s[4],t[2]=s[8],t[3]=s[12],t[4]=s[1],t[5]=s[5],t[6]=s[9],t[7]=s[13],t[8]=s[2],t[9]=s[6],t[10]=s[10],t[11]=s[14],t[12]=s[3],t[13]=s[7],t[14]=s[11],t[15]=s[15];return t}static invert(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8],d=s[9],M=s[10],m=s[11],p=s[12],y=s[13],f=s[14],g=s[15],S=e*a-n*i,x=e*h-r*i,w=e*l-c*i,A=n*h-r*a,z=n*l-c*a,P=r*l-c*h,F=o*y-d*p,q=o*f-M*p,T=o*g-m*p,I=d*f-M*y,U=d*g-m*y,D=M*g-m*f;let v=S*D-x*U+w*I+A*T-z*q+P*F;return v?(v=1/v,t[0]=(a*D-h*U+l*I)*v,t[1]=(r*U-n*D-c*I)*v,t[2]=(y*P-f*z+g*A)*v,t[3]=(M*z-d*P-m*A)*v,t[4]=(h*T-i*D-l*q)*v,t[5]=(e*D-r*T+c*q)*v,t[6]=(f*w-p*P-g*x)*v,t[7]=(o*P-M*w+m*x)*v,t[8]=(i*U-a*T+l*F)*v,t[9]=(n*T-e*U-c*F)*v,t[10]=(p*z-y*w+g*S)*v,t[11]=(d*w-o*z-m*S)*v,t[12]=(a*q-i*I-h*F)*v,t[13]=(e*I-n*q+r*F)*v,t[14]=(y*x-p*A-f*S)*v,t[15]=(o*A-d*x+M*S)*v,t):null}static adjoint(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8],d=s[9],M=s[10],m=s[11],p=s[12],y=s[13],f=s[14],g=s[15],S=e*a-n*i,x=e*h-r*i,w=e*l-c*i,A=n*h-r*a,z=n*l-c*a,P=r*l-c*h,F=o*y-d*p,q=o*f-M*p,T=o*g-m*p,I=d*f-M*y,U=d*g-m*y,D=M*g-m*f;return t[0]=a*D-h*U+l*I,t[1]=r*U-n*D-c*I,t[2]=y*P-f*z+g*A,t[3]=M*z-d*P-m*A,t[4]=h*T-i*D-l*q,t[5]=e*D-r*T+c*q,t[6]=f*w-p*P-g*x,t[7]=o*P-M*w+m*x,t[8]=i*U-a*T+l*F,t[9]=n*T-e*U-c*F,t[10]=p*z-y*w+g*S,t[11]=d*w-o*z-m*S,t[12]=a*q-i*I-h*F,t[13]=e*I-n*q+r*F,t[14]=y*x-p*A-f*S,t[15]=o*A-d*x+M*S,t}static determinant(t){const s=t[0],e=t[1],n=t[2],r=t[3],c=t[4],i=t[5],a=t[6],h=t[7],l=t[8],o=t[9],d=t[10],M=t[11],m=t[12],p=t[13],y=t[14],f=t[15],g=s*i-e*c,S=s*a-n*c,x=e*a-n*i,w=l*p-o*m,A=l*y-d*m,z=o*y-d*p,P=s*z-e*A+n*w,F=c*z-i*A+a*w,q=l*x-o*S+d*g,T=m*x-p*S+y*g;return h*P-r*F+f*q-M*T}static multiply(t,s,e){const n=s[0],r=s[1],c=s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7],d=s[8],M=s[9],m=s[10],p=s[11],y=s[12],f=s[13],g=s[14],S=s[15];let x=e[0],w=e[1],A=e[2],z=e[3];return t[0]=x*n+w*a+A*d+z*y,t[1]=x*r+w*h+A*M+z*f,t[2]=x*c+w*l+A*m+z*g,t[3]=x*i+w*o+A*p+z*S,x=e[4],w=e[5],A=e[6],z=e[7],t[4]=x*n+w*a+A*d+z*y,t[5]=x*r+w*h+A*M+z*f,t[6]=x*c+w*l+A*m+z*g,t[7]=x*i+w*o+A*p+z*S,x=e[8],w=e[9],A=e[10],z=e[11],t[8]=x*n+w*a+A*d+z*y,t[9]=x*r+w*h+A*M+z*f,t[10]=x*c+w*l+A*m+z*g,t[11]=x*i+w*o+A*p+z*S,x=e[12],w=e[13],A=e[14],z=e[15],t[12]=x*n+w*a+A*d+z*y,t[13]=x*r+w*h+A*M+z*f,t[14]=x*c+w*l+A*m+z*g,t[15]=x*i+w*o+A*p+z*S,t}static mul(t,s,e){return t}static translate(t,s,e){const n=e[0],r=e[1],c=e[2];if(s===t)t[12]=s[0]*n+s[4]*r+s[8]*c+s[12],t[13]=s[1]*n+s[5]*r+s[9]*c+s[13],t[14]=s[2]*n+s[6]*r+s[10]*c+s[14],t[15]=s[3]*n+s[7]*r+s[11]*c+s[15];else{const i=s[0],a=s[1],h=s[2],l=s[3],o=s[4],d=s[5],M=s[6],m=s[7],p=s[8],y=s[9],f=s[10],g=s[11];t[0]=i,t[1]=a,t[2]=h,t[3]=l,t[4]=o,t[5]=d,t[6]=M,t[7]=m,t[8]=p,t[9]=y,t[10]=f,t[11]=g,t[12]=i*n+o*r+p*c+s[12],t[13]=a*n+d*r+y*c+s[13],t[14]=h*n+M*r+f*c+s[14],t[15]=l*n+m*r+g*c+s[15]}return t}static scale(t,s,e){const n=e[0],r=e[1],c=e[2];return t[0]=s[0]*n,t[1]=s[1]*n,t[2]=s[2]*n,t[3]=s[3]*n,t[4]=s[4]*r,t[5]=s[5]*r,t[6]=s[6]*r,t[7]=s[7]*r,t[8]=s[8]*c,t[9]=s[9]*c,t[10]=s[10]*c,t[11]=s[11]*c,t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],t}static rotate(t,s,e,n){let r=n[0],c=n[1],i=n[2],a=Math.sqrt(r*r+c*c+i*i);if(a<C)return null;a=1/a,r*=a,c*=a,i*=a;const h=Math.sin(e),l=Math.cos(e),o=1-l,d=s[0],M=s[1],m=s[2],p=s[3],y=s[4],f=s[5],g=s[6],S=s[7],x=s[8],w=s[9],A=s[10],z=s[11],P=r*r*o+l,F=c*r*o+i*h,q=i*r*o-c*h,T=r*c*o-i*h,I=c*c*o+l,U=i*c*o+r*h,D=r*i*o+c*h,v=c*i*o-r*h,N=i*i*o+l;return t[0]=d*P+y*F+x*q,t[1]=M*P+f*F+w*q,t[2]=m*P+g*F+A*q,t[3]=p*P+S*F+z*q,t[4]=d*T+y*I+x*U,t[5]=M*T+f*I+w*U,t[6]=m*T+g*I+A*U,t[7]=p*T+S*I+z*U,t[8]=d*D+y*v+x*N,t[9]=M*D+f*v+w*N,t[10]=m*D+g*v+A*N,t[11]=p*D+S*v+z*N,s!==t&&(t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t}static rotateX(t,s,e){let n=Math.sin(e),r=Math.cos(e),c=s[4],i=s[5],a=s[6],h=s[7],l=s[8],o=s[9],d=s[10],M=s[11];return s!==t&&(t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t[4]=c*r+l*n,t[5]=i*r+o*n,t[6]=a*r+d*n,t[7]=h*r+M*n,t[8]=l*r-c*n,t[9]=o*r-i*n,t[10]=d*r-a*n,t[11]=M*r-h*n,t}static rotateY(t,s,e){let n=Math.sin(e),r=Math.cos(e),c=s[0],i=s[1],a=s[2],h=s[3],l=s[8],o=s[9],d=s[10],M=s[11];return s!==t&&(t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t[0]=c*r-l*n,t[1]=i*r-o*n,t[2]=a*r-d*n,t[3]=h*r-M*n,t[8]=c*n+l*r,t[9]=i*n+o*r,t[10]=a*n+d*r,t[11]=h*n+M*r,t}static rotateZ(t,s,e){let n=Math.sin(e),r=Math.cos(e),c=s[0],i=s[1],a=s[2],h=s[3],l=s[4],o=s[5],d=s[6],M=s[7];return s!==t&&(t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t[0]=c*r+l*n,t[1]=i*r+o*n,t[2]=a*r+d*n,t[3]=h*r+M*n,t[4]=l*r-c*n,t[5]=o*r-i*n,t[6]=d*r-a*n,t[7]=M*r-h*n,t}static fromTranslation(t,s){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=s[0],t[13]=s[1],t[14]=s[2],t[15]=1,t}static fromScaling(t,s){return t[0]=s[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=s[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromRotation(t,s,e){let n=e[0],r=e[1],c=e[2],i=Math.sqrt(n*n+r*r+c*c);if(i<C)return null;i=1/i,n*=i,r*=i,c*=i;const a=Math.sin(s),h=Math.cos(s),l=1-h;return t[0]=n*n*l+h,t[1]=r*n*l+c*a,t[2]=c*n*l-r*a,t[3]=0,t[4]=n*r*l-c*a,t[5]=r*r*l+h,t[6]=c*r*l+n*a,t[7]=0,t[8]=n*c*l+r*a,t[9]=r*c*l-n*a,t[10]=c*c*l+h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromXRotation(t,s){let e=Math.sin(s),n=Math.cos(s);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n,t[6]=e,t[7]=0,t[8]=0,t[9]=-e,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromYRotation(t,s){let e=Math.sin(s),n=Math.cos(s);return t[0]=n,t[1]=0,t[2]=-e,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=e,t[9]=0,t[10]=n,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromZRotation(t,s){const e=Math.sin(s),n=Math.cos(s);return t[0]=n,t[1]=e,t[2]=0,t[3]=0,t[4]=-e,t[5]=n,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromRotationTranslation(t,s,e){const n=s[0],r=s[1],c=s[2],i=s[3],a=n+n,h=r+r,l=c+c,o=n*a,d=n*h,M=n*l,m=r*h,p=r*l,y=c*l,f=i*a,g=i*h,S=i*l;return t[0]=1-(m+y),t[1]=d+S,t[2]=M-g,t[3]=0,t[4]=d-S,t[5]=1-(o+y),t[6]=p+f,t[7]=0,t[8]=M+g,t[9]=p-f,t[10]=1-(o+m),t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}static fromQuat2(t,s){let e=new E;const n=-s[0],r=-s[1],c=-s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7];let d=n*n+r*r+c*c+i*i;return d>0?(e[0]=(a*i+o*n+h*c-l*r)*2/d,e[1]=(h*i+o*r+l*n-a*c)*2/d,e[2]=(l*i+o*c+a*r-h*n)*2/d):(e[0]=(a*i+o*n+h*c-l*r)*2,e[1]=(h*i+o*r+l*n-a*c)*2,e[2]=(l*i+o*c+a*r-h*n)*2),R.fromRotationTranslation(t,s,e),t}static getTranslation(t,s){return t[0]=s[12],t[1]=s[13],t[2]=s[14],t}static getScaling(t,s){const e=s[0],n=s[1],r=s[2],c=s[4],i=s[5],a=s[6],h=s[8],l=s[9],o=s[10];return t[0]=Math.sqrt(e*e+n*n+r*r),t[1]=Math.sqrt(c*c+i*i+a*a),t[2]=Math.sqrt(h*h+l*l+o*o),t}static getRotation(t,s){R.getScaling(H,s);const e=1/H[0],n=1/H[1],r=1/H[2],c=s[0]*e,i=s[1]*n,a=s[2]*r,h=s[4]*e,l=s[5]*n,o=s[6]*r,d=s[8]*e,M=s[9]*n,m=s[10]*r,p=c+l+m;let y=0;return p>0?(y=Math.sqrt(p+1)*2,t[3]=.25*y,t[0]=(o-M)/y,t[1]=(d-a)/y,t[2]=(i-h)/y):c>l&&c>m?(y=Math.sqrt(1+c-l-m)*2,t[3]=(o-M)/y,t[0]=.25*y,t[1]=(i+h)/y,t[2]=(d+a)/y):l>m?(y=Math.sqrt(1+l-c-m)*2,t[3]=(d-a)/y,t[0]=(i+h)/y,t[1]=.25*y,t[2]=(o+M)/y):(y=Math.sqrt(1+m-c-l)*2,t[3]=(i-h)/y,t[0]=(d+a)/y,t[1]=(o+M)/y,t[2]=.25*y),t}static decompose(t,s,e,n){s[0]=n[12],s[1]=n[13],s[2]=n[14];const r=n[0],c=n[1],i=n[2],a=n[4],h=n[5],l=n[6],o=n[8],d=n[9],M=n[10];e[0]=Math.sqrt(r*r+c*c+i*i),e[1]=Math.sqrt(a*a+h*h+l*l),e[2]=Math.sqrt(o*o+d*d+M*M);const m=1/e[0],p=1/e[1],y=1/e[2],f=r*m,g=c*p,S=i*y,x=a*m,w=h*p,A=l*y,z=o*m,P=d*p,F=M*y,q=f+w+F;let T=0;return q>0?(T=Math.sqrt(q+1)*2,t[3]=.25*T,t[0]=(A-P)/T,t[1]=(z-S)/T,t[2]=(g-x)/T):f>w&&f>F?(T=Math.sqrt(1+f-w-F)*2,t[3]=(A-P)/T,t[0]=.25*T,t[1]=(g+x)/T,t[2]=(z+S)/T):w>F?(T=Math.sqrt(1+w-f-F)*2,t[3]=(z-S)/T,t[0]=(g+x)/T,t[1]=.25*T,t[2]=(A+P)/T):(T=Math.sqrt(1+F-f-w)*2,t[3]=(g-x)/T,t[0]=(z+S)/T,t[1]=(A+P)/T,t[2]=.25*T),t}static fromRotationTranslationScale(t,s,e,n){const r=s[0],c=s[1],i=s[2],a=s[3],h=r+r,l=c+c,o=i+i,d=r*h,M=r*l,m=r*o,p=c*l,y=c*o,f=i*o,g=a*h,S=a*l,x=a*o,w=n[0],A=n[1],z=n[2];return t[0]=(1-(p+f))*w,t[1]=(M+x)*w,t[2]=(m-S)*w,t[3]=0,t[4]=(M-x)*A,t[5]=(1-(d+f))*A,t[6]=(y+g)*A,t[7]=0,t[8]=(m+S)*z,t[9]=(y-g)*z,t[10]=(1-(d+p))*z,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}static fromRotationTranslationScaleOrigin(t,s,e,n,r){const c=s[0],i=s[1],a=s[2],h=s[3],l=c+c,o=i+i,d=a+a,M=c*l,m=c*o,p=c*d,y=i*o,f=i*d,g=a*d,S=h*l,x=h*o,w=h*d,A=n[0],z=n[1],P=n[2],F=r[0],q=r[1],T=r[2],I=(1-(y+g))*A,U=(m+w)*A,D=(p-x)*A,v=(m-w)*z,N=(1-(M+g))*z,V=(f+S)*z,G=(p+x)*P,W=(f-S)*P,$=(1-(M+y))*P;return t[0]=I,t[1]=U,t[2]=D,t[3]=0,t[4]=v,t[5]=N,t[6]=V,t[7]=0,t[8]=G,t[9]=W,t[10]=$,t[11]=0,t[12]=e[0]+F-(I*F+v*q+G*T),t[13]=e[1]+q-(U*F+N*q+W*T),t[14]=e[2]+T-(D*F+V*q+$*T),t[15]=1,t}static fromQuat(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=e+e,a=n+n,h=r+r,l=e*i,o=n*i,d=n*a,M=r*i,m=r*a,p=r*h,y=c*i,f=c*a,g=c*h;return t[0]=1-d-p,t[1]=o+g,t[2]=M-f,t[3]=0,t[4]=o-g,t[5]=1-l-p,t[6]=m+y,t[7]=0,t[8]=M+f,t[9]=m-y,t[10]=1-l-d,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static frustum(t,s,e,n,r,c,i){const a=1/(e-s),h=1/(r-n),l=1/(c-i);return t[0]=c*2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c*2*h,t[6]=0,t[7]=0,t[8]=(e+s)*a,t[9]=(r+n)*h,t[10]=(i+c)*l,t[11]=-1,t[12]=0,t[13]=0,t[14]=i*c*2*l,t[15]=0,t}static perspectiveNO(t,s,e,n,r){const c=1/Math.tan(s/2);if(t[0]=c/e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,r!=null&&r!==1/0){const i=1/(n-r);t[10]=(r+n)*i,t[14]=2*r*n*i}else t[10]=-1,t[14]=-2*n;return t}static perspective(t,s,e,n,r){return t}static perspectiveZO(t,s,e,n,r){const c=1/Math.tan(s/2);if(t[0]=c/e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,r!=null&&r!==1/0){const i=1/(n-r);t[10]=r*i,t[14]=r*n*i}else t[10]=-1,t[14]=-n;return t}static perspectiveFromFieldOfView(t,s,e,n){const r=Math.tan(s.upDegrees*Math.PI/180),c=Math.tan(s.downDegrees*Math.PI/180),i=Math.tan(s.leftDegrees*Math.PI/180),a=Math.tan(s.rightDegrees*Math.PI/180),h=2/(i+a),l=2/(r+c);return t[0]=h,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=l,t[6]=0,t[7]=0,t[8]=-((i-a)*h*.5),t[9]=(r-c)*l*.5,t[10]=n/(e-n),t[11]=-1,t[12]=0,t[13]=0,t[14]=n*e/(e-n),t[15]=0,t}static orthoNO(t,s,e,n,r,c,i){const a=1/(s-e),h=1/(n-r),l=1/(c-i);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*h,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*l,t[11]=0,t[12]=(s+e)*a,t[13]=(r+n)*h,t[14]=(i+c)*l,t[15]=1,t}static ortho(t,s,e,n,r,c,i){return t}static orthoZO(t,s,e,n,r,c,i){const a=1/(s-e),h=1/(n-r),l=1/(c-i);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*h,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=l,t[11]=0,t[12]=(s+e)*a,t[13]=(r+n)*h,t[14]=c*l,t[15]=1,t}static lookAt(t,s,e,n){const r=s[0],c=s[1],i=s[2],a=n[0],h=n[1],l=n[2],o=e[0],d=e[1],M=e[2];if(Math.abs(r-o)<C&&Math.abs(c-d)<C&&Math.abs(i-M)<C)return R.identity(t);let m=r-o,p=c-d,y=i-M,f=1/Math.sqrt(m*m+p*p+y*y);m*=f,p*=f,y*=f;let g=h*y-l*p,S=l*m-a*y,x=a*p-h*m;f=Math.sqrt(g*g+S*S+x*x),f?(f=1/f,g*=f,S*=f,x*=f):(g=0,S=0,x=0);let w=p*x-y*S,A=y*g-m*x,z=m*S-p*g;return f=Math.sqrt(w*w+A*A+z*z),f?(f=1/f,w*=f,A*=f,z*=f):(w=0,A=0,z=0),t[0]=g,t[1]=w,t[2]=m,t[3]=0,t[4]=S,t[5]=A,t[6]=p,t[7]=0,t[8]=x,t[9]=z,t[10]=y,t[11]=0,t[12]=-(g*r+S*c+x*i),t[13]=-(w*r+A*c+z*i),t[14]=-(m*r+p*c+y*i),t[15]=1,t}static targetTo(t,s,e,n){const r=s[0],c=s[1],i=s[2],a=n[0],h=n[1],l=n[2];let o=r-e[0],d=c-e[1],M=i-e[2],m=o*o+d*d+M*M;m>0&&(m=1/Math.sqrt(m),o*=m,d*=m,M*=m);let p=h*M-l*d,y=l*o-a*M,f=a*d-h*o;return m=p*p+y*y+f*f,m>0&&(m=1/Math.sqrt(m),p*=m,y*=m,f*=m),t[0]=p,t[1]=y,t[2]=f,t[3]=0,t[4]=d*f-M*y,t[5]=M*p-o*f,t[6]=o*y-d*p,t[7]=0,t[8]=o,t[9]=d,t[10]=M,t[11]=0,t[12]=r,t[13]=c,t[14]=i,t[15]=1,t}static frob(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]+t[4]*t[4]+t[5]*t[5]+t[6]*t[6]+t[7]*t[7]+t[8]*t[8]+t[9]*t[9]+t[10]*t[10]+t[11]*t[11]+t[12]*t[12]+t[13]*t[13]+t[14]*t[14]+t[15]*t[15])}static add(t,s,e){return t[0]=s[0]+e[0],t[1]=s[1]+e[1],t[2]=s[2]+e[2],t[3]=s[3]+e[3],t[4]=s[4]+e[4],t[5]=s[5]+e[5],t[6]=s[6]+e[6],t[7]=s[7]+e[7],t[8]=s[8]+e[8],t[9]=s[9]+e[9],t[10]=s[10]+e[10],t[11]=s[11]+e[11],t[12]=s[12]+e[12],t[13]=s[13]+e[13],t[14]=s[14]+e[14],t[15]=s[15]+e[15],t}static subtract(t,s,e){return t[0]=s[0]-e[0],t[1]=s[1]-e[1],t[2]=s[2]-e[2],t[3]=s[3]-e[3],t[4]=s[4]-e[4],t[5]=s[5]-e[5],t[6]=s[6]-e[6],t[7]=s[7]-e[7],t[8]=s[8]-e[8],t[9]=s[9]-e[9],t[10]=s[10]-e[10],t[11]=s[11]-e[11],t[12]=s[12]-e[12],t[13]=s[13]-e[13],t[14]=s[14]-e[14],t[15]=s[15]-e[15],t}static sub(t,s,e){return t}static multiplyScalar(t,s,e){return t[0]=s[0]*e,t[1]=s[1]*e,t[2]=s[2]*e,t[3]=s[3]*e,t[4]=s[4]*e,t[5]=s[5]*e,t[6]=s[6]*e,t[7]=s[7]*e,t[8]=s[8]*e,t[9]=s[9]*e,t[10]=s[10]*e,t[11]=s[11]*e,t[12]=s[12]*e,t[13]=s[13]*e,t[14]=s[14]*e,t[15]=s[15]*e,t}static multiplyScalarAndAdd(t,s,e,n){return t[0]=s[0]+e[0]*n,t[1]=s[1]+e[1]*n,t[2]=s[2]+e[2]*n,t[3]=s[3]+e[3]*n,t[4]=s[4]+e[4]*n,t[5]=s[5]+e[5]*n,t[6]=s[6]+e[6]*n,t[7]=s[7]+e[7]*n,t[8]=s[8]+e[8]*n,t[9]=s[9]+e[9]*n,t[10]=s[10]+e[10]*n,t[11]=s[11]+e[11]*n,t[12]=s[12]+e[12]*n,t[13]=s[13]+e[13]*n,t[14]=s[14]+e[14]*n,t[15]=s[15]+e[15]*n,t}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]&&t[3]===s[3]&&t[4]===s[4]&&t[5]===s[5]&&t[6]===s[6]&&t[7]===s[7]&&t[8]===s[8]&&t[9]===s[9]&&t[10]===s[10]&&t[11]===s[11]&&t[12]===s[12]&&t[13]===s[13]&&t[14]===s[14]&&t[15]===s[15]}static equals(t,s){const e=t[0],n=t[1],r=t[2],c=t[3],i=t[4],a=t[5],h=t[6],l=t[7],o=t[8],d=t[9],M=t[10],m=t[11],p=t[12],y=t[13],f=t[14],g=t[15],S=s[0],x=s[1],w=s[2],A=s[3],z=s[4],P=s[5],F=s[6],q=s[7],T=s[8],I=s[9],U=s[10],D=s[11],v=s[12],N=s[13],V=s[14],G=s[15];return Math.abs(e-S)<=C*Math.max(1,Math.abs(e),Math.abs(S))&&Math.abs(n-x)<=C*Math.max(1,Math.abs(n),Math.abs(x))&&Math.abs(r-w)<=C*Math.max(1,Math.abs(r),Math.abs(w))&&Math.abs(c-A)<=C*Math.max(1,Math.abs(c),Math.abs(A))&&Math.abs(i-z)<=C*Math.max(1,Math.abs(i),Math.abs(z))&&Math.abs(a-P)<=C*Math.max(1,Math.abs(a),Math.abs(P))&&Math.abs(h-F)<=C*Math.max(1,Math.abs(h),Math.abs(F))&&Math.abs(l-q)<=C*Math.max(1,Math.abs(l),Math.abs(q))&&Math.abs(o-T)<=C*Math.max(1,Math.abs(o),Math.abs(T))&&Math.abs(d-I)<=C*Math.max(1,Math.abs(d),Math.abs(I))&&Math.abs(M-U)<=C*Math.max(1,Math.abs(M),Math.abs(U))&&Math.abs(m-D)<=C*Math.max(1,Math.abs(m),Math.abs(D))&&Math.abs(p-v)<=C*Math.max(1,Math.abs(p),Math.abs(v))&&Math.abs(y-N)<=C*Math.max(1,Math.abs(y),Math.abs(N))&&Math.abs(f-V)<=C*Math.max(1,Math.abs(f),Math.abs(V))&&Math.abs(g-G)<=C*Math.max(1,Math.abs(g),Math.abs(G))}static str(t){return`Mat4(${t.join(", ")})`}}const H=new E;R.prototype.mul=R.prototype.multiply;R.sub=R.subtract;R.mul=R.multiply;R.perspective=R.perspectiveNO;R.ortho=R.orthoNO;class L extends Float32Array{static BYTE_LENGTH=4*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 4:super(t);break;case 2:super(t[0],t[1],4);break;case 1:{const s=t[0];typeof s=="number"?super([s,s,s,s]):super(s,0,4);break}default:super(4);break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get w(){return this[3]}set w(t){this[3]=t}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get b(){return this[2]}set b(t){this[2]=t}get a(){return this[3]}set a(t){this[3]=t}get magnitude(){const t=this[0],s=this[1],e=this[2],n=this[3];return Math.sqrt(t*t+s*s+e*e+n*n)}get mag(){return this.magnitude}get str(){return L.str(this)}copy(t){return super.set(t),this}add(t){return this[0]+=t[0],this[1]+=t[1],this[2]+=t[2],this[3]+=t[3],this}subtract(t){return this[0]-=t[0],this[1]-=t[1],this[2]-=t[2],this[3]-=t[3],this}sub(t){return this}multiply(t){return this[0]*=t[0],this[1]*=t[1],this[2]*=t[2],this[3]*=t[3],this}mul(t){return this}divide(t){return this[0]/=t[0],this[1]/=t[1],this[2]/=t[2],this[3]/=t[3],this}div(t){return this}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this[3]*=t,this}scaleAndAdd(t,s){return this[0]+=t[0]*s,this[1]+=t[1]*s,this[2]+=t[2]*s,this[3]+=t[3]*s,this}distance(t){return L.distance(this,t)}dist(t){return 0}squaredDistance(t){return L.squaredDistance(this,t)}sqrDist(t){return 0}negate(){return this[0]*=-1,this[1]*=-1,this[2]*=-1,this[3]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this[3]=1/this[3],this}dot(t){return this[0]*t[0]+this[1]*t[1]+this[2]*t[2]+this[3]*t[3]}normalize(){return L.normalize(this,this)}static create(){return new L}static clone(t){return new L(t)}static fromValues(t,s,e,n){return new L(t,s,e,n)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t}static set(t,s,e,n,r){return t[0]=s,t[1]=e,t[2]=n,t[3]=r,t}static add(t,s,e){return t[0]=s[0]+e[0],t[1]=s[1]+e[1],t[2]=s[2]+e[2],t[3]=s[3]+e[3],t}static subtract(t,s,e){return t[0]=s[0]-e[0],t[1]=s[1]-e[1],t[2]=s[2]-e[2],t[3]=s[3]-e[3],t}static sub(t,s,e){return t}static multiply(t,s,e){return t[0]=s[0]*e[0],t[1]=s[1]*e[1],t[2]=s[2]*e[2],t[3]=s[3]*e[3],t}static mul(t,s,e){return t}static divide(t,s,e){return t[0]=s[0]/e[0],t[1]=s[1]/e[1],t[2]=s[2]/e[2],t[3]=s[3]/e[3],t}static div(t,s,e){return t}static ceil(t,s){return t[0]=Math.ceil(s[0]),t[1]=Math.ceil(s[1]),t[2]=Math.ceil(s[2]),t[3]=Math.ceil(s[3]),t}static floor(t,s){return t[0]=Math.floor(s[0]),t[1]=Math.floor(s[1]),t[2]=Math.floor(s[2]),t[3]=Math.floor(s[3]),t}static min(t,s,e){return t[0]=Math.min(s[0],e[0]),t[1]=Math.min(s[1],e[1]),t[2]=Math.min(s[2],e[2]),t[3]=Math.min(s[3],e[3]),t}static max(t,s,e){return t[0]=Math.max(s[0],e[0]),t[1]=Math.max(s[1],e[1]),t[2]=Math.max(s[2],e[2]),t[3]=Math.max(s[3],e[3]),t}static round(t,s){return t[0]=Math.round(s[0]),t[1]=Math.round(s[1]),t[2]=Math.round(s[2]),t[3]=Math.round(s[3]),t}static scale(t,s,e){return t[0]=s[0]*e,t[1]=s[1]*e,t[2]=s[2]*e,t[3]=s[3]*e,t}static scaleAndAdd(t,s,e,n){return t[0]=s[0]+e[0]*n,t[1]=s[1]+e[1]*n,t[2]=s[2]+e[2]*n,t[3]=s[3]+e[3]*n,t}static distance(t,s){const e=s[0]-t[0],n=s[1]-t[1],r=s[2]-t[2],c=s[3]-t[3];return Math.hypot(e,n,r,c)}static dist(t,s){return 0}static squaredDistance(t,s){const e=s[0]-t[0],n=s[1]-t[1],r=s[2]-t[2],c=s[3]-t[3];return e*e+n*n+r*r+c*c}static sqrDist(t,s){return 0}static magnitude(t){const s=t[0],e=t[1],n=t[2],r=t[3];return Math.sqrt(s*s+e*e+n*n+r*r)}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static squaredLength(t){const s=t[0],e=t[1],n=t[2],r=t[3];return s*s+e*e+n*n+r*r}static sqrLen(t){return 0}static negate(t,s){return t[0]=-s[0],t[1]=-s[1],t[2]=-s[2],t[3]=-s[3],t}static inverse(t,s){return t[0]=1/s[0],t[1]=1/s[1],t[2]=1/s[2],t[3]=1/s[3],t}static normalize(t,s){const e=s[0],n=s[1],r=s[2],c=s[3];let i=e*e+n*n+r*r+c*c;return i>0&&(i=1/Math.sqrt(i)),t[0]=e*i,t[1]=n*i,t[2]=r*i,t[3]=c*i,t}static dot(t,s){return t[0]*s[0]+t[1]*s[1]+t[2]*s[2]+t[3]*s[3]}static cross(t,s,e,n){const r=e[0]*n[1]-e[1]*n[0],c=e[0]*n[2]-e[2]*n[0],i=e[0]*n[3]-e[3]*n[0],a=e[1]*n[2]-e[2]*n[1],h=e[1]*n[3]-e[3]*n[1],l=e[2]*n[3]-e[3]*n[2],o=s[0],d=s[1],M=s[2],m=s[3];return t[0]=d*l-M*h+m*a,t[1]=-(o*l)+M*i-m*c,t[2]=o*h-d*i+m*r,t[3]=-(o*a)+d*c-M*r,t}static lerp(t,s,e,n){const r=s[0],c=s[1],i=s[2],a=s[3];return t[0]=r+n*(e[0]-r),t[1]=c+n*(e[1]-c),t[2]=i+n*(e[2]-i),t[3]=a+n*(e[3]-a),t}static transformMat4(t,s,e){const n=s[0],r=s[1],c=s[2],i=s[3];return t[0]=e[0]*n+e[4]*r+e[8]*c+e[12]*i,t[1]=e[1]*n+e[5]*r+e[9]*c+e[13]*i,t[2]=e[2]*n+e[6]*r+e[10]*c+e[14]*i,t[3]=e[3]*n+e[7]*r+e[11]*c+e[15]*i,t}static transformQuat(t,s,e){const n=s[0],r=s[1],c=s[2],i=e[0],a=e[1],h=e[2],l=e[3],o=l*n+a*c-h*r,d=l*r+h*n-i*c,M=l*c+i*r-a*n,m=-i*n-a*r-h*c;return t[0]=o*l+m*-i+d*-h-M*-a,t[1]=d*l+m*-a+M*-i-o*-h,t[2]=M*l+m*-h+o*-a-d*-i,t[3]=s[3],t}static zero(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}static str(t){return`Vec4(${t.join(", ")})`}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]&&t[3]===s[3]}static equals(t,s){const e=t[0],n=t[1],r=t[2],c=t[3],i=s[0],a=s[1],h=s[2],l=s[3];return Math.abs(e-i)<=C*Math.max(1,Math.abs(e),Math.abs(i))&&Math.abs(n-a)<=C*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(r-h)<=C*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(c-l)<=C*Math.max(1,Math.abs(c),Math.abs(l))}}L.prototype.sub=L.prototype.subtract;L.prototype.mul=L.prototype.multiply;L.prototype.div=L.prototype.divide;L.prototype.dist=L.prototype.distance;L.prototype.sqrDist=L.prototype.squaredDistance;L.sub=L.subtract;L.mul=L.multiply;L.div=L.divide;L.dist=L.distance;L.sqrDist=L.squaredDistance;L.sqrLen=L.squaredLength;L.mag=L.magnitude;L.length=L.magnitude;L.len=L.magnitude;class b extends Float32Array{static BYTE_LENGTH=4*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 4:super(t);break;case 2:super(t[0],t[1],4);break;case 1:{const s=t[0];typeof s=="number"?super([s,s,s,s]):super(s,0,4);break}default:super(4),this[3]=1;break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get w(){return this[3]}set w(t){this[3]=t}get magnitude(){const t=this[0],s=this[1],e=this[2],n=this[3];return Math.sqrt(t*t+s*s+e*e+n*n)}get mag(){return this.magnitude}get str(){return b.str(this)}copy(t){return super.set(t),this}identity(){return this[0]=0,this[1]=0,this[2]=0,this[3]=1,this}multiply(t){return b.multiply(this,this,t)}mul(t){return this}rotateX(t){return b.rotateX(this,this,t)}rotateY(t){return b.rotateY(this,this,t)}rotateZ(t){return b.rotateZ(this,this,t)}invert(){return b.invert(this,this)}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this[3]*=t,this}dot(t){return b.dot(this,t)}static create(){return new b}static identity(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}static setAxisAngle(t,s,e){e=e*.5;const n=Math.sin(e);return t[0]=n*s[0],t[1]=n*s[1],t[2]=n*s[2],t[3]=Math.cos(e),t}static getAxisAngle(t,s){const e=Math.acos(s[3])*2,n=Math.sin(e/2);return n>C?(t[0]=s[0]/n,t[1]=s[1]/n,t[2]=s[2]/n):(t[0]=1,t[1]=0,t[2]=0),e}static getAngle(t,s){const e=b.dot(t,s);return Math.acos(2*e*e-1)}static multiply(t,s,e){const n=s[0],r=s[1],c=s[2],i=s[3],a=e[0],h=e[1],l=e[2],o=e[3];return t[0]=n*o+i*a+r*l-c*h,t[1]=r*o+i*h+c*a-n*l,t[2]=c*o+i*l+n*h-r*a,t[3]=i*o-n*a-r*h-c*l,t}static rotateX(t,s,e){e*=.5;const n=s[0],r=s[1],c=s[2],i=s[3],a=Math.sin(e),h=Math.cos(e);return t[0]=n*h+i*a,t[1]=r*h+c*a,t[2]=c*h-r*a,t[3]=i*h-n*a,t}static rotateY(t,s,e){e*=.5;const n=s[0],r=s[1],c=s[2],i=s[3],a=Math.sin(e),h=Math.cos(e);return t[0]=n*h-c*a,t[1]=r*h+i*a,t[2]=c*h+n*a,t[3]=i*h-r*a,t}static rotateZ(t,s,e){e*=.5;const n=s[0],r=s[1],c=s[2],i=s[3],a=Math.sin(e),h=Math.cos(e);return t[0]=n*h+r*a,t[1]=r*h-n*a,t[2]=c*h+i*a,t[3]=i*h-c*a,t}static calculateW(t,s){const e=s[0],n=s[1],r=s[2];return t[0]=e,t[1]=n,t[2]=r,t[3]=Math.sqrt(Math.abs(1-e*e-n*n-r*r)),t}static exp(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=Math.sqrt(e*e+n*n+r*r),a=Math.exp(c),h=i>0?a*Math.sin(i)/i:0;return t[0]=e*h,t[1]=n*h,t[2]=r*h,t[3]=a*Math.cos(i),t}static ln(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=Math.sqrt(e*e+n*n+r*r),a=i>0?Math.atan2(i,c)/i:0;return t[0]=e*a,t[1]=n*a,t[2]=r*a,t[3]=.5*Math.log(e*e+n*n+r*r+c*c),t}static pow(t,s,e){return b.ln(t,s),b.scale(t,t,e),b.exp(t,t),t}static slerp(t,s,e,n){const r=s[0],c=s[1],i=s[2],a=s[3];let h=e[0],l=e[1],o=e[2],d=e[3],M,m,p=r*h+c*l+i*o+a*d;if(p<0&&(p=-p,h=-h,l=-l,o=-o,d=-d),1-p>C){const y=Math.acos(p),f=Math.sin(y);M=Math.sin((1-n)*y)/f,m=Math.sin(n*y)/f}else M=1-n,m=n;return t[0]=M*r+m*h,t[1]=M*c+m*l,t[2]=M*i+m*o,t[3]=M*a+m*d,t}static invert(t,s){const e=s[0],n=s[1],r=s[2],c=s[3],i=e*e+n*n+r*r+c*c,a=i?1/i:0;return t[0]=-e*a,t[1]=-n*a,t[2]=-r*a,t[3]=c*a,t}static conjugate(t,s){return t[0]=-s[0],t[1]=-s[1],t[2]=-s[2],t[3]=s[3],t}static fromMat3(t,s){const e=s[0]+s[4]+s[8];let n;if(e>0)n=Math.sqrt(e+1),t[3]=.5*n,n=.5/n,t[0]=(s[5]-s[7])*n,t[1]=(s[6]-s[2])*n,t[2]=(s[1]-s[3])*n;else{let r=0;s[4]>s[0]&&(r=1),s[8]>s[r*3+r]&&(r=2);let c=(r+1)%3,i=(r+2)%3;n=Math.sqrt(s[r*3+r]-s[c*3+c]-s[i*3+i]+1),t[r]=.5*n,n=.5/n,t[3]=(s[c*3+i]-s[i*3+c])*n,t[c]=(s[c*3+r]+s[r*3+c])*n,t[i]=(s[i*3+r]+s[r*3+i])*n}return t}static fromEuler(t,s,e,n){let r=.5*Math.PI/180;s*=r,e*=r,n*=r;let c=Math.sin(s),i=Math.cos(s),a=Math.sin(e),h=Math.cos(e),l=Math.sin(n),o=Math.cos(n);return t[0]=c*h*o-i*a*l,t[1]=i*a*o+c*h*l,t[2]=i*h*l-c*a*o,t[3]=i*h*o+c*a*l,t}static str(t){return`Quat(${t.join(", ")})`}static clone(t){return new b(t)}static fromValues(t,s,e,n){return new b(t,s,e,n)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t}static set(t,s,e,n,r){return t}static add(t,s,e){return t}static mul(t,s,e){return t}static scale(t,s,e){return t[0]=s[0]*e,t[1]=s[1]*e,t[2]=s[2]*e,t[3]=s[3]*e,t}static dot(t,s){return t[0]*s[0]+t[1]*s[1]+t[2]*s[2]+t[3]*s[3]}static lerp(t,s,e,n){return t}static magnitude(t){return 0}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static squaredLength(t){return 0}static sqrLen(t){return 0}static normalize(t,s){return t}static exactEquals(t,s){return!1}static equals(t,s){return!1}static rotationTo(t,s,e){let n=E.dot(s,e);return n<-.999999?(E.cross(Y,ct,s),E.len(Y)<1e-6&&E.cross(Y,it,s),E.normalize(Y,Y),b.setAxisAngle(t,Y,Math.PI),t):n>.999999?(t[0]=0,t[1]=0,t[2]=0,t[3]=1,t):(E.cross(Y,s,e),t[0]=Y[0],t[1]=Y[1],t[2]=Y[2],t[3]=1+n,b.normalize(t,t))}static sqlerp(t,s,e,n,r,c){return b.slerp(Q,s,r,c),b.slerp(_,e,n,c),b.slerp(t,Q,_,2*c*(1-c)),t}static setAxes(t,s,e,n){return k[0]=e[0],k[3]=e[1],k[6]=e[2],k[1]=n[0],k[4]=n[1],k[7]=n[2],k[2]=-s[0],k[5]=-s[1],k[8]=-s[2],b.normalize(t,b.fromMat3(t,k))}}const Q=new b,_=new b,k=new B,Y=new E,ct=new E(1,0,0),it=new E(0,1,0);b.set=L.set;b.add=L.add;b.lerp=L.lerp;b.normalize=L.normalize;b.squaredLength=L.squaredLength;b.sqrLen=L.squaredLength;b.exactEquals=L.exactEquals;b.equals=L.equals;b.magnitude=L.magnitude;b.prototype.mul=b.prototype.multiply;b.mul=b.multiply;b.mag=b.magnitude;b.length=b.magnitude;b.len=b.magnitude;class X{fov;aspect;near;far;active=!0;constructor(t=90,s=1,e=.1,n=1e3){this.fov=t,this.aspect=s,this.near=e,this.far=n}getProjectionMatrix(t){let s=new R;const e=t??this.aspect,n=2*Math.atan(Math.tan(this.fov*Math.PI/360)/e)*180/Math.PI;return R.perspectiveNO(s,n*Math.PI/180,e,this.near,this.far),s}setActive(t){this.active=t}}class at{type;color;intensity;constructor(t="point",s=new E(1,1,1),e=1){this.type=t,this.color=s,this.intensity=e}}class tt{modelGL;constructor(t){this.modelGL=t}getVAO(){return this.modelGL.vao}getVertexCount(){return this.modelGL.vertexCount}}class j{position=new E(0,0,0);rotation=new b(0,0,0,1);scale=new E(1,1,1);constructor(){}setPosition(t){this.position=t}setRotationQuat(t){this.rotation=t}setRotationEuler(t){b.fromEuler(this.rotation,t.x,t.y,t.z)}setScale(t){this.position=t}getPosition(){return this.position}getRotation(){return this.rotation}getRotationEuler(){return this.toEulerXYZ(this.rotation)}toEulerXYZ(t){const s=t.w*t.x,e=t.w*t.y,n=t.w*t.z,r=t.x*t.x,c=t.x*t.y,i=t.x*t.z,a=t.y*t.y,h=t.y*t.z,l=t.z*t.z;return new E(-Math.atan2(2*(h-s),1-2*(r+a))*180/Math.PI,Math.asin(2*(i+e))*180/Math.PI,-Math.atan2(2*(c-n),1-2*(a+l))*180/Math.PI)}getScale(){return this.scale}lookAt(t,s=new E(0,1,0)){const e=new E;E.subtract(e,t,this.position),E.normalize(e,e);const n=new R;R.targetTo(n,this.position,t,s);const r=new b;R.getRotation(r,n),this.rotation=r}getLocalMatrix(){const t=new R;return R.fromRotationTranslationScale(t,this.rotation,this.position,this.scale),t}getViewMatrix(){const t=new R,s=new b;b.invert(s,this.rotation);const e=new E;return E.negate(e,this.position),E.transformQuat(e,e,s),R.fromRotationTranslation(t,s,e),t}}class ht{nextId=0;entities=new Set;constructor(){}create(){const t=this.nextId++;return this.entities.add(t),t}destroy(t){this.entities.delete(t)}getAll(){return Array.from(this.entities)}}class st{}class lt{systems=[];add(t){this.systems.push(t)}update(t,s){for(const e of this.systems)e.update(t,s)}}class ot{entities;components;systems;constructor(){this.entities=new ht,this.components=new rt,this.systems=new lt}createEntity(){const t=this.entities.create();return this.components.add(t,new j),t}createCamera(){const t=this.createEntity();return this.components.add(t,new X),t}createLight(t){const s=this.createEntity();return this.components.add(s,new at(t)),s}createMesh(t,s){const e=this.createEntity();return this.components.add(e,new tt(t)),this.components.add(e,s),e}}class dt{ecs;name;active;activeCamera=null;constructor(t="Untitled"){this.name=t,this.active=!0,this.ecs=new ot}update(t){this.active&&this.ecs.systems.update(t,this.ecs.components)}createCamera(){const t=this.ecs.createCamera();return this.activeCamera===null&&(this.activeCamera=t),t}setActiveCamera(t){if(!this.ecs.components.get(t,X))throw new Error("L'entité donnée n'a pas de composant Camera");this.activeCamera=t}getActiveCamera(){return this.activeCamera}createEntity(){return this.ecs.createEntity()}createLight(t){return this.ecs.createLight(t)}createMesh(t,s){return this.ecs.createMesh(t,s)}destroyEntity(t){t===this.activeCamera&&(this.activeCamera=null),this.ecs.entities.destroy(t)}getComponent(t,s){return this.ecs.components.get(t,s)}getAllComponentOfType(t){return this.ecs.components.getAllOfType(t)}addSystem(t){this.ecs.systems.add(t)}}class mt{canvas;gl;constructor(t){this.canvas=t;const s=t.getContext("webgl2");if(s)console.log("WebGL2 context initialized",s);else throw new Error("WebGL2 non supporté par ce navigateur");this.gl=s,this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA),this.gl.enable(this.gl.CULL_FACE),this.gl.cullFace(this.gl.BACK),this.resizeCanvas(),window.addEventListener("resize",this.resizeCanvas.bind(this))}clear(t=0,s=0,e=0,n=1){this.gl.clearColor(t,s,e,n),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT)}setViewport(t,s){console.log("Set viewport",t,s),this.gl.viewport(0,0,t,s)}enableDepthTest(){this.gl.enable(this.gl.DEPTH_TEST)}resizeCanvas(){console.log("Resizing canvas to",window.innerWidth,window.innerHeight),this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight,this.setViewport(this.canvas.width,this.canvas.height)}getAspectRatio(){return this.canvas.width/this.canvas.height}}class Mt{glContext;scene=null;constructor(t){this.glContext=new mt(t)}start(){let t=performance.now();const s=e=>{const n=(e-t)/1e3;t=e,this.scene&&this.scene.update(n),requestAnimationFrame(s)};requestAnimationFrame(s)}setScene(t){this.scene=t}}class pt{gl;program;uniformLocations=new Map;pendingUniforms=new Map;dirtyUniforms=new Set;constructor(t,s){this.gl=t;const e=this.compile(t.VERTEX_SHADER,s.vertexShader),n=this.compile(t.FRAGMENT_SHADER,s.fragmentShader),r=t.createProgram();if(!r)throw new Error("Impossible de créer le programme WebGL.");if(t.attachShader(r,e),t.attachShader(r,n),t.linkProgram(r),!t.getProgramParameter(r,t.LINK_STATUS)){const c=t.getProgramInfoLog(r);throw new Error("Erreur de linkage du shader: "+c)}t.deleteShader(e),t.deleteShader(n),this.program=r}use(){this.gl.useProgram(this.program);for(const[t,s]of this.pendingUniforms.entries())this.applyUniform(t,s);this.dirtyUniforms.clear()}getUniformLocation(t){if(this.uniformLocations.has(t))return this.uniformLocations.get(t);const s=this.gl.getUniformLocation(this.program,t);if(!s)throw new Error(`Uniform "${t}" introuvable dans le shader.`);return this.uniformLocations.set(t,s),s}set(t,s){this.pendingUniforms.set(t,s),this.dirtyUniforms.add(t)}setUniform(t,s){this.applyUniform(t,s)}applyUniform(t,s){const e=this.getUniformLocation(t),n={1:(c,i)=>typeof i=="number"?this.gl.uniform1f(c,i):this.gl.uniform1iv(c,i),2:(c,i)=>this.gl.uniform2fv(c,i),3:(c,i)=>this.gl.uniform3fv(c,i),4:(c,i)=>Array.isArray(i)||i instanceof Float32Array?this.gl.uniform4fv(c,i):this.gl.uniformMatrix2fv(c,!1,i),9:(c,i)=>this.gl.uniformMatrix3fv(c,!1,i),16:(c,i)=>this.gl.uniformMatrix4fv(c,!1,i)},r=typeof s=="number"?1:s.length;n[r](e,s)}compile(t,s){const e=this.gl.createShader(t);if(!e)throw new Error("Cannot create shader.");if(this.gl.shaderSource(e,s),this.gl.compileShader(e),!this.gl.getShaderParameter(e,this.gl.COMPILE_STATUS)){const n=this.gl.getShaderInfoLog(e);throw new Error("Shader compilation error: "+n)}return e}delete(){this.gl.deleteProgram(this.program)}}class et{shader;uniforms={};constructor(t){this.shader=t}setUniform(t,s){this.uniforms[t]=s}applyUniforms(){for(const[t,s]of Object.entries(this.uniforms))this.shader.setUniform(t,s)}}class u{vertexShader;fragmentShader;geometryShader;tessControlShader;tessEvalShader;constructor(t,s,e,n,r){this.vertexShader=t,this.fragmentShader=s,this.geometryShader=e,this.tessControlShader=n,this.tessEvalShader=r}}class yt{static async LoadShaderFile(t){const s=await fetch(t);if(!s.ok)throw new Error(`Erreur lors du chargement du shader: ${t}`);return await s.text()}static async LoadShaderFolder(t){t.endsWith("/")||(t+="/"),console.log("Try to load shaders from folder",t);const e=(t.endsWith("/")?t:t+"/").split("/").filter(Boolean),n=e[e.length-1],r=[{ext:".vs",key:"vertexShader"},{ext:".fs",key:"fragmentShader"},{ext:".gs",key:"geometryShader"},{ext:".ts",key:"tessControlShader"},{ext:".tes",key:"tessEvalShader"}];let c="",i="",a,h,l;if(await Promise.all(r.map(async({ext:o,key:d})=>{const M=t+n+o;try{const m=await fetch(M);if(m.ok){const p=await m.text();switch(d){case"vertexShader":c=p;break;case"fragmentShader":i=p;break;case"geometryShader":a=p;break;case"tessControlShader":h=p;break;case"tessEvalShader":l=p;break}}}catch{}})),!c||!i)throw new Error("Le dossier ne contient pas de vertexShader (.vs) ou fragmentShader (.fs)");return console.log("Loaded shaders from folder",t),new u(c,i,a,h,l)}static testShader(){const t=`#version 300 es
        precision highp float;

        in vec3 a_position;

        uniform mat4 u_proj;
        uniform mat4 u_view;
        uniform mat4 u_model;


        void main() {
            vec4 worldPos = u_model * vec4(a_position, 1.0);
            gl_Position = u_proj * u_view * worldPos;
        }
        `,s=`#version 300 es
        precision highp float;
        out vec4 outColor;
        void main() {
            outColor = vec4(1.0,0.0,0.0, 1.0);
        }
        `;return new u(t,s)}}class Z{vao;vertexCount;constructor(t,s){this.vao=t,this.vertexCount=s}static generate(t,s,e,n,r){const c=t.createVertexArray();t.bindVertexArray(c);const i=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,new Float32Array(s),t.STATIC_DRAW);const a=0;t.enableVertexAttribArray(a),t.vertexAttribPointer(a,3,t.FLOAT,!1,0,0);let h=null;if(n&&n.length>0){h=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,h),t.bufferData(t.ARRAY_BUFFER,new Float32Array(n),t.STATIC_DRAW);const d=1;t.enableVertexAttribArray(d),t.vertexAttribPointer(d,3,t.FLOAT,!1,0,0)}let l=null;if(r&&r.length>0){l=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,l),t.bufferData(t.ARRAY_BUFFER,new Float32Array(r),t.STATIC_DRAW);const d=2;t.enableVertexAttribArray(d),t.vertexAttribPointer(d,2,t.FLOAT,!1,0,0)}const o=t.createBuffer();return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,o),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array(e),t.STATIC_DRAW),t.bindVertexArray(null),new Z(c,e.length)}}class ft{static generateCube(t,s){const e=s/2,n=[-e,-e,-e,e,-e,-e,e,e,-e,-e,e,-e,-e,-e,e,e,-e,e,e,e,e,-e,e,e],r=[-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1],c=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1],i=[0,2,1,0,3,2,4,5,6,4,6,7,4,3,0,4,7,3,1,6,5,1,2,6,3,6,2,3,7,6,4,1,5,4,0,1];return Z.generate(t,n,i,r,c)}static generateCube24Vertex(t,s){const e=s/2,n=[-e,-e,e,e,-e,e,e,e,e,-e,e,e,-e,-e,-e,-e,e,-e,e,e,-e,e,-e,-e,-e,-e,-e,-e,-e,e,-e,e,e,-e,e,-e,e,-e,-e,e,e,-e,e,e,e,e,-e,e,-e,e,-e,-e,e,e,e,e,e,e,e,-e,-e,-e,-e,e,-e,-e,e,-e,e,-e,-e,e],r=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],c=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1],i=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];return Z.generate(t,n,i,r,c)}static LoadFromURL(t,s){return null}static generateTriangle(t){const s=[-.5,.5,0,-.5,-.5,0,.5,-.5,0],e=[0,0,1,0,0,1,0,0,1],n=[0,1,0,0,1,0],r=[0,1,2];return Z.generate(t,s,r,e,n)}}class gt extends st{engine;constructor(t){super(),this.engine=t}update(t,s){if(!this.engine.scene)return;const e=this.engine.scene.getActiveCamera();if(!e)throw new Error("No active camera in the scene");this.engine.glContext.clear(0,0,0,1);const n=s.get(e,X),r=s.get(e,j),c=s.getAllOfType(tt),i=r.getViewMatrix(),a=n.getProjectionMatrix(this.engine.glContext.getAspectRatio());for(const[h,l]of c){const o=s.get(h,j),d=s.get(h,et);!o||!d||(d.shader.use(),d.shader.setUniform("u_proj",a),d.shader.setUniform("u_view",i),d.shader.setUniform("u_model",o.getLocalMatrix()),d.shader.setUniform("u_cameraPos",r.getPosition()),d.applyUniforms(),l.getVAO()&&(this.engine.glContext.gl.bindVertexArray(l.getVAO()),this.engine.glContext.gl.drawElements(this.engine.glContext.gl.TRIANGLES,l.getVertexCount(),this.engine.glContext.gl.UNSIGNED_SHORT,0),this.engine.glContext.gl.bindVertexArray(null)))}}}class xt extends st{mainEntity;targetEntity;radius;azimuth;elevation;speed;constructor(t,s,e=5,n=0,r=0,c=30){super(),this.mainEntity=t,this.targetEntity=s,this.radius=e,this.azimuth=n,this.elevation=r,this.speed=c}update(t,s){this.azimuth+=this.speed*t,this.azimuth>360&&(this.azimuth-=360),this.azimuth<0&&(this.azimuth+=360);const e=s.get(this.mainEntity,j),n=s.get(this.targetEntity,j);if(!e||!n)return;const r=n.getPosition(),c=this.azimuth*Math.PI/180,i=this.elevation*Math.PI/180,a=r.x+this.radius*Math.cos(i)*Math.cos(c),h=r.y+this.radius*Math.sin(i),l=r.z+this.radius*Math.cos(i)*Math.sin(c);e.setPosition(new E(a,h,l)),e.lookAt(r)}}async function wt(O){console.log("Initializing Engine...");const t=new Mt(O);console.log("Initializing Scene...");const s=new dt,e=new pt(t.glContext.gl,await yt.LoadShaderFolder("/assets/shaders/pbr"));e.set("u_lightDir",new Float32Array([.5,1,.5])),e.set("u_lightColor",new Float32Array([1,1,1])),e.set("u_albedo",new Float32Array([10,0,0])),e.set("u_useAlbedoMap",0),e.set("u_metallic",0),e.set("u_roughness",0);const n=s.createMesh(ft.generateCube(t.glContext.gl,1.5),new et(e));s.getComponent(n,j).setPosition(new E(0,0,0));const r=s.createCamera();s.setActiveCamera(r);const c=s.getComponent(r,j);c.setPosition(new E(2,2,2)),c.lookAt(new E(0,0,0)),s.addSystem(new gt(t)),s.addSystem(new xt(r,n,5,45,30,20)),t.setScene(s),console.log("Start engine..."),t.start(),console.log("Engine started.")}let nt=document.querySelector("#glCanvas");console.log(nt);wt(nt);
