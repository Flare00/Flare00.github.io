(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const e of document.querySelectorAll('link[rel="modulepreload"]'))n(e);new MutationObserver(e=>{for(const r of e)if(r.type==="childList")for(const c of r.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&n(c)}).observe(document,{childList:!0,subtree:!0});function s(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerPolicy&&(r.referrerPolicy=e.referrerPolicy),e.crossOrigin==="use-credentials"?r.credentials="include":e.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(e){if(e.ep)return;e.ep=!0;const r=s(e);fetch(e.href,r)}})();class et{components=new Map;add(t,s){const n=s.constructor.name;this.components.has(n)||this.components.set(n,new Map),this.components.get(n).set(t,s)}remove(t,s){this.components.get(s.name)?.delete(t)}get(t,s){return this.components.get(s.name)?.get(t)}getAllOfType(t){const s=this.components.get(t.name);return s?Array.from(s.entries()):[]}}const q=1e-6,K=new Float32Array([1,0,0,0,1,0,0,0,1]);class N extends Float32Array{static BYTE_LENGTH=9*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 9:super(t);break;case 2:super(t[0],t[1],9);break;case 1:const s=t[0];typeof s=="number"?super([s,s,s,s,s,s,s,s,s]):super(s,0,9);break;default:super(K);break}}get str(){return N.str(this)}copy(t){return this.set(t),this}identity(){return this.set(K),this}multiply(t){return N.multiply(this,this,t)}mul(t){return this}transpose(){return N.transpose(this,this)}invert(){return N.invert(this,this)}translate(t){return N.translate(this,this,t)}rotate(t){return N.rotate(this,this,t)}scale(t){return N.scale(this,this,t)}static create(){return new N}static clone(t){return new N(t)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t}static fromValues(...t){return new N(...t)}static set(t,...s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t}static identity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}static transpose(t,s){if(t===s){const n=s[1],e=s[2],r=s[5];t[1]=s[3],t[2]=s[6],t[3]=n,t[5]=s[7],t[6]=e,t[7]=r}else t[0]=s[0],t[1]=s[3],t[2]=s[6],t[3]=s[1],t[4]=s[4],t[5]=s[7],t[6]=s[2],t[7]=s[5],t[8]=s[8];return t}static invert(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8],p=o*i-a*l,m=-o*c+a*h,M=l*c-i*h;let y=n*p+e*m+r*M;return y?(y=1/y,t[0]=p*y,t[1]=(-o*e+r*l)*y,t[2]=(a*e-r*i)*y,t[3]=m*y,t[4]=(o*n-r*h)*y,t[5]=(-a*n+r*c)*y,t[6]=M*y,t[7]=(-l*n+e*h)*y,t[8]=(i*n-e*c)*y,t):null}static adjoint(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8];return t[0]=i*o-a*l,t[1]=r*l-e*o,t[2]=e*a-r*i,t[3]=a*h-c*o,t[4]=n*o-r*h,t[5]=r*c-n*a,t[6]=c*l-i*h,t[7]=e*h-n*l,t[8]=n*i-e*c,t}static determinant(t){const s=t[0],n=t[1],e=t[2],r=t[3],c=t[4],i=t[5],a=t[6],h=t[7],l=t[8];return s*(l*c-i*h)+n*(-l*r+i*a)+e*(h*r-c*a)}static add(t,s,n){return t[0]=s[0]+n[0],t[1]=s[1]+n[1],t[2]=s[2]+n[2],t[3]=s[3]+n[3],t[4]=s[4]+n[4],t[5]=s[5]+n[5],t[6]=s[6]+n[6],t[7]=s[7]+n[7],t[8]=s[8]+n[8],t}static subtract(t,s,n){return t[0]=s[0]-n[0],t[1]=s[1]-n[1],t[2]=s[2]-n[2],t[3]=s[3]-n[3],t[4]=s[4]-n[4],t[5]=s[5]-n[5],t[6]=s[6]-n[6],t[7]=s[7]-n[7],t[8]=s[8]-n[8],t}static sub(t,s,n){return t}static multiply(t,s,n){const e=s[0],r=s[1],c=s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7],p=s[8];let m=n[0],M=n[1],y=n[2];return t[0]=m*e+M*i+y*l,t[1]=m*r+M*a+y*o,t[2]=m*c+M*h+y*p,m=n[3],M=n[4],y=n[5],t[3]=m*e+M*i+y*l,t[4]=m*r+M*a+y*o,t[5]=m*c+M*h+y*p,m=n[6],M=n[7],y=n[8],t[6]=m*e+M*i+y*l,t[7]=m*r+M*a+y*o,t[8]=m*c+M*h+y*p,t}static mul(t,s,n){return t}static translate(t,s,n){const e=s[0],r=s[1],c=s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7],p=s[8],m=n[0],M=n[1];return t[0]=e,t[1]=r,t[2]=c,t[3]=i,t[4]=a,t[5]=h,t[6]=m*e+M*i+l,t[7]=m*r+M*a+o,t[8]=m*c+M*h+p,t}static rotate(t,s,n){const e=s[0],r=s[1],c=s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7],p=s[8],m=Math.sin(n),M=Math.cos(n);return t[0]=M*e+m*i,t[1]=M*r+m*a,t[2]=M*c+m*h,t[3]=M*i-m*e,t[4]=M*a-m*r,t[5]=M*h-m*c,t[6]=l,t[7]=o,t[8]=p,t}static scale(t,s,n){const e=n[0],r=n[1];return t[0]=e*s[0],t[1]=e*s[1],t[2]=e*s[2],t[3]=r*s[3],t[4]=r*s[4],t[5]=r*s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t}static fromTranslation(t,s){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=s[0],t[7]=s[1],t[8]=1,t}static fromRotation(t,s){const n=Math.sin(s),e=Math.cos(s);return t[0]=e,t[1]=n,t[2]=0,t[3]=-n,t[4]=e,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}static fromScaling(t,s){return t[0]=s[0],t[1]=0,t[2]=0,t[3]=0,t[4]=s[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}static fromMat2d(t,s){return t[0]=s[0],t[1]=s[1],t[2]=0,t[3]=s[2],t[4]=s[3],t[5]=0,t[6]=s[4],t[7]=s[5],t[8]=1,t}static fromQuat(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=n+n,a=e+e,h=r+r,l=n*i,o=e*i,p=e*a,m=r*i,M=r*a,y=r*h,d=c*i,g=c*a,f=c*h;return t[0]=1-p-y,t[3]=o-f,t[6]=m+g,t[1]=o+f,t[4]=1-l-y,t[7]=M-d,t[2]=m-g,t[5]=M+d,t[8]=1-l-p,t}static fromMat4(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[4],t[4]=s[5],t[5]=s[6],t[6]=s[8],t[7]=s[9],t[8]=s[10],t}static normalFromMat4(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8],p=s[9],m=s[10],M=s[11],y=s[12],d=s[13],g=s[14],f=s[15],T=n*a-e*i,x=n*h-r*i,w=n*l-c*i,E=e*h-r*a,z=e*l-c*a,P=r*l-c*h,F=o*d-p*y,O=o*g-m*y,S=o*f-M*y,I=p*g-m*d,v=p*f-M*d,D=m*f-M*g;let C=T*D-x*v+w*I+E*S-z*O+P*F;return C?(C=1/C,t[0]=(a*D-h*v+l*I)*C,t[1]=(h*S-i*D-l*O)*C,t[2]=(i*v-a*S+l*F)*C,t[3]=(r*v-e*D-c*I)*C,t[4]=(n*D-r*S+c*O)*C,t[5]=(e*S-n*v-c*F)*C,t[6]=(d*P-g*z+f*E)*C,t[7]=(g*w-y*P-f*x)*C,t[8]=(y*z-d*w+f*T)*C,t):null}static projection(t,s,n){return t[0]=2/s,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/n,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t}static frob(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]+t[4]*t[4]+t[5]*t[5]+t[6]*t[6]+t[7]*t[7]+t[8]*t[8])}static multiplyScalar(t,s,n){return t[0]=s[0]*n,t[1]=s[1]*n,t[2]=s[2]*n,t[3]=s[3]*n,t[4]=s[4]*n,t[5]=s[5]*n,t[6]=s[6]*n,t[7]=s[7]*n,t[8]=s[8]*n,t}static multiplyScalarAndAdd(t,s,n,e){return t[0]=s[0]+n[0]*e,t[1]=s[1]+n[1]*e,t[2]=s[2]+n[2]*e,t[3]=s[3]+n[3]*e,t[4]=s[4]+n[4]*e,t[5]=s[5]+n[5]*e,t[6]=s[6]+n[6]*e,t[7]=s[7]+n[7]*e,t[8]=s[8]+n[8]*e,t}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]&&t[3]===s[3]&&t[4]===s[4]&&t[5]===s[5]&&t[6]===s[6]&&t[7]===s[7]&&t[8]===s[8]}static equals(t,s){const n=t[0],e=t[1],r=t[2],c=t[3],i=t[4],a=t[5],h=t[6],l=t[7],o=t[8],p=s[0],m=s[1],M=s[2],y=s[3],d=s[4],g=s[5],f=s[6],T=s[7],x=s[8];return Math.abs(n-p)<=q*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(e-m)<=q*Math.max(1,Math.abs(e),Math.abs(m))&&Math.abs(r-M)<=q*Math.max(1,Math.abs(r),Math.abs(M))&&Math.abs(c-y)<=q*Math.max(1,Math.abs(c),Math.abs(y))&&Math.abs(i-d)<=q*Math.max(1,Math.abs(i),Math.abs(d))&&Math.abs(a-g)<=q*Math.max(1,Math.abs(a),Math.abs(g))&&Math.abs(h-f)<=q*Math.max(1,Math.abs(h),Math.abs(f))&&Math.abs(l-T)<=q*Math.max(1,Math.abs(l),Math.abs(T))&&Math.abs(o-x)<=q*Math.max(1,Math.abs(o),Math.abs(x))}static str(t){return`Mat3(${t.join(", ")})`}}N.prototype.mul=N.prototype.multiply;N.mul=N.multiply;N.sub=N.subtract;class A extends Float32Array{static BYTE_LENGTH=3*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 3:super(t);break;case 2:super(t[0],t[1],3);break;case 1:{const s=t[0];typeof s=="number"?super([s,s,s]):super(s,0,3);break}default:super(3);break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get b(){return this[2]}set b(t){this[2]=t}get magnitude(){const t=this[0],s=this[1],n=this[2];return Math.sqrt(t*t+s*s+n*n)}get mag(){return this.magnitude}get squaredMagnitude(){const t=this[0],s=this[1],n=this[2];return t*t+s*s+n*n}get sqrMag(){return this.squaredMagnitude}get str(){return A.str(this)}copy(t){return this.set(t),this}add(t){return this[0]+=t[0],this[1]+=t[1],this[2]+=t[2],this}subtract(t){return this[0]-=t[0],this[1]-=t[1],this[2]-=t[2],this}sub(t){return this}multiply(t){return this[0]*=t[0],this[1]*=t[1],this[2]*=t[2],this}mul(t){return this}divide(t){return this[0]/=t[0],this[1]/=t[1],this[2]/=t[2],this}div(t){return this}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this}scaleAndAdd(t,s){return this[0]+=t[0]*s,this[1]+=t[1]*s,this[2]+=t[2]*s,this}distance(t){return A.distance(this,t)}dist(t){return 0}squaredDistance(t){return A.squaredDistance(this,t)}sqrDist(t){return 0}negate(){return this[0]*=-1,this[1]*=-1,this[2]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this}dot(t){return this[0]*t[0]+this[1]*t[1]+this[2]*t[2]}normalize(){return A.normalize(this,this)}static create(){return new A}static clone(t){return new A(t)}static magnitude(t){let s=t[0],n=t[1],e=t[2];return Math.sqrt(s*s+n*n+e*e)}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static fromValues(t,s,n){return new A(t,s,n)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t}static set(t,s,n,e){return t[0]=s,t[1]=n,t[2]=e,t}static add(t,s,n){return t[0]=s[0]+n[0],t[1]=s[1]+n[1],t[2]=s[2]+n[2],t}static subtract(t,s,n){return t[0]=s[0]-n[0],t[1]=s[1]-n[1],t[2]=s[2]-n[2],t}static sub(t,s,n){return[0,0,0]}static multiply(t,s,n){return t[0]=s[0]*n[0],t[1]=s[1]*n[1],t[2]=s[2]*n[2],t}static mul(t,s,n){return[0,0,0]}static divide(t,s,n){return t[0]=s[0]/n[0],t[1]=s[1]/n[1],t[2]=s[2]/n[2],t}static div(t,s,n){return[0,0,0]}static ceil(t,s){return t[0]=Math.ceil(s[0]),t[1]=Math.ceil(s[1]),t[2]=Math.ceil(s[2]),t}static floor(t,s){return t[0]=Math.floor(s[0]),t[1]=Math.floor(s[1]),t[2]=Math.floor(s[2]),t}static min(t,s,n){return t[0]=Math.min(s[0],n[0]),t[1]=Math.min(s[1],n[1]),t[2]=Math.min(s[2],n[2]),t}static max(t,s,n){return t[0]=Math.max(s[0],n[0]),t[1]=Math.max(s[1],n[1]),t[2]=Math.max(s[2],n[2]),t}static scale(t,s,n){return t[0]=s[0]*n,t[1]=s[1]*n,t[2]=s[2]*n,t}static scaleAndAdd(t,s,n,e){return t[0]=s[0]+n[0]*e,t[1]=s[1]+n[1]*e,t[2]=s[2]+n[2]*e,t}static distance(t,s){const n=s[0]-t[0],e=s[1]-t[1],r=s[2]-t[2];return Math.sqrt(n*n+e*e+r*r)}static dist(t,s){return 0}static squaredDistance(t,s){const n=s[0]-t[0],e=s[1]-t[1],r=s[2]-t[2];return n*n+e*e+r*r}static sqrDist(t,s){return 0}static squaredLength(t){const s=t[0],n=t[1],e=t[2];return s*s+n*n+e*e}static sqrLen(t,s){return 0}static negate(t,s){return t[0]=-s[0],t[1]=-s[1],t[2]=-s[2],t}static inverse(t,s){return t[0]=1/s[0],t[1]=1/s[1],t[2]=1/s[2],t}static normalize(t,s){const n=s[0],e=s[1],r=s[2];let c=n*n+e*e+r*r;return c>0&&(c=1/Math.sqrt(c)),t[0]=s[0]*c,t[1]=s[1]*c,t[2]=s[2]*c,t}static dot(t,s){return t[0]*s[0]+t[1]*s[1]+t[2]*s[2]}static cross(t,s,n){const e=s[0],r=s[1],c=s[2],i=n[0],a=n[1],h=n[2];return t[0]=r*h-c*a,t[1]=c*i-e*h,t[2]=e*a-r*i,t}static lerp(t,s,n,e){const r=s[0],c=s[1],i=s[2];return t[0]=r+e*(n[0]-r),t[1]=c+e*(n[1]-c),t[2]=i+e*(n[2]-i),t}static slerp(t,s,n,e){const r=Math.acos(Math.min(Math.max(A.dot(s,n),-1),1)),c=Math.sin(r),i=Math.sin((1-e)*r)/c,a=Math.sin(e*r)/c;return t[0]=i*s[0]+a*n[0],t[1]=i*s[1]+a*n[1],t[2]=i*s[2]+a*n[2],t}static hermite(t,s,n,e,r,c){const i=c*c,a=i*(2*c-3)+1,h=i*(c-2)+c,l=i*(c-1),o=i*(3-2*c);return t[0]=s[0]*a+n[0]*h+e[0]*l+r[0]*o,t[1]=s[1]*a+n[1]*h+e[1]*l+r[1]*o,t[2]=s[2]*a+n[2]*h+e[2]*l+r[2]*o,t}static bezier(t,s,n,e,r,c){const i=1-c,a=i*i,h=c*c,l=a*i,o=3*c*a,p=3*h*i,m=h*c;return t[0]=s[0]*l+n[0]*o+e[0]*p+r[0]*m,t[1]=s[1]*l+n[1]*o+e[1]*p+r[1]*m,t[2]=s[2]*l+n[2]*o+e[2]*p+r[2]*m,t}static transformMat4(t,s,n){const e=s[0],r=s[1],c=s[2],i=n[3]*e+n[7]*r+n[11]*c+n[15]||1;return t[0]=(n[0]*e+n[4]*r+n[8]*c+n[12])/i,t[1]=(n[1]*e+n[5]*r+n[9]*c+n[13])/i,t[2]=(n[2]*e+n[6]*r+n[10]*c+n[14])/i,t}static transformMat3(t,s,n){let e=s[0],r=s[1],c=s[2];return t[0]=e*n[0]+r*n[3]+c*n[6],t[1]=e*n[1]+r*n[4]+c*n[7],t[2]=e*n[2]+r*n[5]+c*n[8],t}static transformQuat(t,s,n){const e=n[0],r=n[1],c=n[2],i=n[3]*2,a=s[0],h=s[1],l=s[2],o=r*l-c*h,p=c*a-e*l,m=e*h-r*a,M=(r*m-c*p)*2,y=(c*o-e*m)*2,d=(e*p-r*o)*2;return t[0]=a+o*i+M,t[1]=h+p*i+y,t[2]=l+m*i+d,t}static rotateX(t,s,n,e){const r=n[1],c=n[2],i=s[1]-r,a=s[2]-c;return t[0]=s[0],t[1]=i*Math.cos(e)-a*Math.sin(e)+r,t[2]=i*Math.sin(e)+a*Math.cos(e)+c,t}static rotateY(t,s,n,e){const r=n[0],c=n[2],i=s[0]-r,a=s[2]-c;return t[0]=a*Math.sin(e)+i*Math.cos(e)+r,t[1]=s[1],t[2]=a*Math.cos(e)-i*Math.sin(e)+c,t}static rotateZ(t,s,n,e){const r=n[0],c=n[1],i=s[0]-r,a=s[1]-c;return t[0]=i*Math.cos(e)-a*Math.sin(e)+r,t[1]=i*Math.sin(e)+a*Math.cos(e)+c,t[2]=n[2],t}static angle(t,s){const n=t[0],e=t[1],r=t[2],c=s[0],i=s[1],a=s[2],h=Math.sqrt((n*n+e*e+r*r)*(c*c+i*i+a*a)),l=h&&A.dot(t,s)/h;return Math.acos(Math.min(Math.max(l,-1),1))}static zero(t){return t[0]=0,t[1]=0,t[2]=0,t}static str(t){return`Vec3(${t.join(", ")})`}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]}static equals(t,s){const n=t[0],e=t[1],r=t[2],c=s[0],i=s[1],a=s[2];return Math.abs(n-c)<=q*Math.max(1,Math.abs(n),Math.abs(c))&&Math.abs(e-i)<=q*Math.max(1,Math.abs(e),Math.abs(i))&&Math.abs(r-a)<=q*Math.max(1,Math.abs(r),Math.abs(a))}}A.prototype.sub=A.prototype.subtract;A.prototype.mul=A.prototype.multiply;A.prototype.div=A.prototype.divide;A.prototype.dist=A.prototype.distance;A.prototype.sqrDist=A.prototype.squaredDistance;A.sub=A.subtract;A.mul=A.multiply;A.div=A.divide;A.dist=A.distance;A.sqrDist=A.squaredDistance;A.sqrLen=A.squaredLength;A.mag=A.magnitude;A.length=A.magnitude;A.len=A.magnitude;const J=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);class R extends Float32Array{static BYTE_LENGTH=16*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 16:super(t);break;case 2:super(t[0],t[1],16);break;case 1:const s=t[0];typeof s=="number"?super([s,s,s,s,s,s,s,s,s,s,s,s,s,s,s,s]):super(s,0,16);break;default:super(J);break}}get str(){return R.str(this)}copy(t){return this.set(t),this}identity(){return this.set(J),this}multiply(t){return R.multiply(this,this,t)}mul(t){return this}transpose(){return R.transpose(this,this)}invert(){return R.invert(this,this)}translate(t){return R.translate(this,this,t)}rotate(t,s){return R.rotate(this,this,t,s)}scale(t){return R.scale(this,this,t)}rotateX(t){return R.rotateX(this,this,t)}rotateY(t){return R.rotateY(this,this,t)}rotateZ(t){return R.rotateZ(this,this,t)}perspectiveNO(t,s,n,e){return R.perspectiveNO(this,t,s,n,e)}perspectiveZO(t,s,n,e){return R.perspectiveZO(this,t,s,n,e)}orthoNO(t,s,n,e,r,c){return R.orthoNO(this,t,s,n,e,r,c)}orthoZO(t,s,n,e,r,c){return R.orthoZO(this,t,s,n,e,r,c)}static create(){return new R}static clone(t){return new R(t)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],t}static fromValues(...t){return new R(...t)}static set(t,...s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],t}static identity(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static transpose(t,s){if(t===s){const n=s[1],e=s[2],r=s[3],c=s[6],i=s[7],a=s[11];t[1]=s[4],t[2]=s[8],t[3]=s[12],t[4]=n,t[6]=s[9],t[7]=s[13],t[8]=e,t[9]=c,t[11]=s[14],t[12]=r,t[13]=i,t[14]=a}else t[0]=s[0],t[1]=s[4],t[2]=s[8],t[3]=s[12],t[4]=s[1],t[5]=s[5],t[6]=s[9],t[7]=s[13],t[8]=s[2],t[9]=s[6],t[10]=s[10],t[11]=s[14],t[12]=s[3],t[13]=s[7],t[14]=s[11],t[15]=s[15];return t}static invert(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8],p=s[9],m=s[10],M=s[11],y=s[12],d=s[13],g=s[14],f=s[15],T=n*a-e*i,x=n*h-r*i,w=n*l-c*i,E=e*h-r*a,z=e*l-c*a,P=r*l-c*h,F=o*d-p*y,O=o*g-m*y,S=o*f-M*y,I=p*g-m*d,v=p*f-M*d,D=m*f-M*g;let C=T*D-x*v+w*I+E*S-z*O+P*F;return C?(C=1/C,t[0]=(a*D-h*v+l*I)*C,t[1]=(r*v-e*D-c*I)*C,t[2]=(d*P-g*z+f*E)*C,t[3]=(m*z-p*P-M*E)*C,t[4]=(h*S-i*D-l*O)*C,t[5]=(n*D-r*S+c*O)*C,t[6]=(g*w-y*P-f*x)*C,t[7]=(o*P-m*w+M*x)*C,t[8]=(i*v-a*S+l*F)*C,t[9]=(e*S-n*v-c*F)*C,t[10]=(y*z-d*w+f*T)*C,t[11]=(p*w-o*z-M*T)*C,t[12]=(a*O-i*I-h*F)*C,t[13]=(n*I-e*O+r*F)*C,t[14]=(d*x-y*E-g*T)*C,t[15]=(o*E-p*x+m*T)*C,t):null}static adjoint(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=s[4],a=s[5],h=s[6],l=s[7],o=s[8],p=s[9],m=s[10],M=s[11],y=s[12],d=s[13],g=s[14],f=s[15],T=n*a-e*i,x=n*h-r*i,w=n*l-c*i,E=e*h-r*a,z=e*l-c*a,P=r*l-c*h,F=o*d-p*y,O=o*g-m*y,S=o*f-M*y,I=p*g-m*d,v=p*f-M*d,D=m*f-M*g;return t[0]=a*D-h*v+l*I,t[1]=r*v-e*D-c*I,t[2]=d*P-g*z+f*E,t[3]=m*z-p*P-M*E,t[4]=h*S-i*D-l*O,t[5]=n*D-r*S+c*O,t[6]=g*w-y*P-f*x,t[7]=o*P-m*w+M*x,t[8]=i*v-a*S+l*F,t[9]=e*S-n*v-c*F,t[10]=y*z-d*w+f*T,t[11]=p*w-o*z-M*T,t[12]=a*O-i*I-h*F,t[13]=n*I-e*O+r*F,t[14]=d*x-y*E-g*T,t[15]=o*E-p*x+m*T,t}static determinant(t){const s=t[0],n=t[1],e=t[2],r=t[3],c=t[4],i=t[5],a=t[6],h=t[7],l=t[8],o=t[9],p=t[10],m=t[11],M=t[12],y=t[13],d=t[14],g=t[15],f=s*i-n*c,T=s*a-e*c,x=n*a-e*i,w=l*y-o*M,E=l*d-p*M,z=o*d-p*y,P=s*z-n*E+e*w,F=c*z-i*E+a*w,O=l*x-o*T+p*f,S=M*x-y*T+d*f;return h*P-r*F+g*O-m*S}static multiply(t,s,n){const e=s[0],r=s[1],c=s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7],p=s[8],m=s[9],M=s[10],y=s[11],d=s[12],g=s[13],f=s[14],T=s[15];let x=n[0],w=n[1],E=n[2],z=n[3];return t[0]=x*e+w*a+E*p+z*d,t[1]=x*r+w*h+E*m+z*g,t[2]=x*c+w*l+E*M+z*f,t[3]=x*i+w*o+E*y+z*T,x=n[4],w=n[5],E=n[6],z=n[7],t[4]=x*e+w*a+E*p+z*d,t[5]=x*r+w*h+E*m+z*g,t[6]=x*c+w*l+E*M+z*f,t[7]=x*i+w*o+E*y+z*T,x=n[8],w=n[9],E=n[10],z=n[11],t[8]=x*e+w*a+E*p+z*d,t[9]=x*r+w*h+E*m+z*g,t[10]=x*c+w*l+E*M+z*f,t[11]=x*i+w*o+E*y+z*T,x=n[12],w=n[13],E=n[14],z=n[15],t[12]=x*e+w*a+E*p+z*d,t[13]=x*r+w*h+E*m+z*g,t[14]=x*c+w*l+E*M+z*f,t[15]=x*i+w*o+E*y+z*T,t}static mul(t,s,n){return t}static translate(t,s,n){const e=n[0],r=n[1],c=n[2];if(s===t)t[12]=s[0]*e+s[4]*r+s[8]*c+s[12],t[13]=s[1]*e+s[5]*r+s[9]*c+s[13],t[14]=s[2]*e+s[6]*r+s[10]*c+s[14],t[15]=s[3]*e+s[7]*r+s[11]*c+s[15];else{const i=s[0],a=s[1],h=s[2],l=s[3],o=s[4],p=s[5],m=s[6],M=s[7],y=s[8],d=s[9],g=s[10],f=s[11];t[0]=i,t[1]=a,t[2]=h,t[3]=l,t[4]=o,t[5]=p,t[6]=m,t[7]=M,t[8]=y,t[9]=d,t[10]=g,t[11]=f,t[12]=i*e+o*r+y*c+s[12],t[13]=a*e+p*r+d*c+s[13],t[14]=h*e+m*r+g*c+s[14],t[15]=l*e+M*r+f*c+s[15]}return t}static scale(t,s,n){const e=n[0],r=n[1],c=n[2];return t[0]=s[0]*e,t[1]=s[1]*e,t[2]=s[2]*e,t[3]=s[3]*e,t[4]=s[4]*r,t[5]=s[5]*r,t[6]=s[6]*r,t[7]=s[7]*r,t[8]=s[8]*c,t[9]=s[9]*c,t[10]=s[10]*c,t[11]=s[11]*c,t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],t}static rotate(t,s,n,e){let r=e[0],c=e[1],i=e[2],a=Math.sqrt(r*r+c*c+i*i);if(a<q)return null;a=1/a,r*=a,c*=a,i*=a;const h=Math.sin(n),l=Math.cos(n),o=1-l,p=s[0],m=s[1],M=s[2],y=s[3],d=s[4],g=s[5],f=s[6],T=s[7],x=s[8],w=s[9],E=s[10],z=s[11],P=r*r*o+l,F=c*r*o+i*h,O=i*r*o-c*h,S=r*c*o-i*h,I=c*c*o+l,v=i*c*o+r*h,D=r*i*o+c*h,C=c*i*o-r*h,B=i*i*o+l;return t[0]=p*P+d*F+x*O,t[1]=m*P+g*F+w*O,t[2]=M*P+f*F+E*O,t[3]=y*P+T*F+z*O,t[4]=p*S+d*I+x*v,t[5]=m*S+g*I+w*v,t[6]=M*S+f*I+E*v,t[7]=y*S+T*I+z*v,t[8]=p*D+d*C+x*B,t[9]=m*D+g*C+w*B,t[10]=M*D+f*C+E*B,t[11]=y*D+T*C+z*B,s!==t&&(t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t}static rotateX(t,s,n){let e=Math.sin(n),r=Math.cos(n),c=s[4],i=s[5],a=s[6],h=s[7],l=s[8],o=s[9],p=s[10],m=s[11];return s!==t&&(t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t[4]=c*r+l*e,t[5]=i*r+o*e,t[6]=a*r+p*e,t[7]=h*r+m*e,t[8]=l*r-c*e,t[9]=o*r-i*e,t[10]=p*r-a*e,t[11]=m*r-h*e,t}static rotateY(t,s,n){let e=Math.sin(n),r=Math.cos(n),c=s[0],i=s[1],a=s[2],h=s[3],l=s[8],o=s[9],p=s[10],m=s[11];return s!==t&&(t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t[0]=c*r-l*e,t[1]=i*r-o*e,t[2]=a*r-p*e,t[3]=h*r-m*e,t[8]=c*e+l*r,t[9]=i*e+o*r,t[10]=a*e+p*r,t[11]=h*e+m*r,t}static rotateZ(t,s,n){let e=Math.sin(n),r=Math.cos(n),c=s[0],i=s[1],a=s[2],h=s[3],l=s[4],o=s[5],p=s[6],m=s[7];return s!==t&&(t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15]),t[0]=c*r+l*e,t[1]=i*r+o*e,t[2]=a*r+p*e,t[3]=h*r+m*e,t[4]=l*r-c*e,t[5]=o*r-i*e,t[6]=p*r-a*e,t[7]=m*r-h*e,t}static fromTranslation(t,s){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=s[0],t[13]=s[1],t[14]=s[2],t[15]=1,t}static fromScaling(t,s){return t[0]=s[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=s[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromRotation(t,s,n){let e=n[0],r=n[1],c=n[2],i=Math.sqrt(e*e+r*r+c*c);if(i<q)return null;i=1/i,e*=i,r*=i,c*=i;const a=Math.sin(s),h=Math.cos(s),l=1-h;return t[0]=e*e*l+h,t[1]=r*e*l+c*a,t[2]=c*e*l-r*a,t[3]=0,t[4]=e*r*l-c*a,t[5]=r*r*l+h,t[6]=c*r*l+e*a,t[7]=0,t[8]=e*c*l+r*a,t[9]=r*c*l-e*a,t[10]=c*c*l+h,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromXRotation(t,s){let n=Math.sin(s),e=Math.cos(s);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e,t[6]=n,t[7]=0,t[8]=0,t[9]=-n,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromYRotation(t,s){let n=Math.sin(s),e=Math.cos(s);return t[0]=e,t[1]=0,t[2]=-n,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=n,t[9]=0,t[10]=e,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromZRotation(t,s){const n=Math.sin(s),e=Math.cos(s);return t[0]=e,t[1]=n,t[2]=0,t[3]=0,t[4]=-n,t[5]=e,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static fromRotationTranslation(t,s,n){const e=s[0],r=s[1],c=s[2],i=s[3],a=e+e,h=r+r,l=c+c,o=e*a,p=e*h,m=e*l,M=r*h,y=r*l,d=c*l,g=i*a,f=i*h,T=i*l;return t[0]=1-(M+d),t[1]=p+T,t[2]=m-f,t[3]=0,t[4]=p-T,t[5]=1-(o+d),t[6]=y+g,t[7]=0,t[8]=m+f,t[9]=y-g,t[10]=1-(o+M),t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}static fromQuat2(t,s){let n=new A;const e=-s[0],r=-s[1],c=-s[2],i=s[3],a=s[4],h=s[5],l=s[6],o=s[7];let p=e*e+r*r+c*c+i*i;return p>0?(n[0]=(a*i+o*e+h*c-l*r)*2/p,n[1]=(h*i+o*r+l*e-a*c)*2/p,n[2]=(l*i+o*c+a*r-h*e)*2/p):(n[0]=(a*i+o*e+h*c-l*r)*2,n[1]=(h*i+o*r+l*e-a*c)*2,n[2]=(l*i+o*c+a*r-h*e)*2),R.fromRotationTranslation(t,s,n),t}static getTranslation(t,s){return t[0]=s[12],t[1]=s[13],t[2]=s[14],t}static getScaling(t,s){const n=s[0],e=s[1],r=s[2],c=s[4],i=s[5],a=s[6],h=s[8],l=s[9],o=s[10];return t[0]=Math.sqrt(n*n+e*e+r*r),t[1]=Math.sqrt(c*c+i*i+a*a),t[2]=Math.sqrt(h*h+l*l+o*o),t}static getRotation(t,s){R.getScaling(X,s);const n=1/X[0],e=1/X[1],r=1/X[2],c=s[0]*n,i=s[1]*e,a=s[2]*r,h=s[4]*n,l=s[5]*e,o=s[6]*r,p=s[8]*n,m=s[9]*e,M=s[10]*r,y=c+l+M;let d=0;return y>0?(d=Math.sqrt(y+1)*2,t[3]=.25*d,t[0]=(o-m)/d,t[1]=(p-a)/d,t[2]=(i-h)/d):c>l&&c>M?(d=Math.sqrt(1+c-l-M)*2,t[3]=(o-m)/d,t[0]=.25*d,t[1]=(i+h)/d,t[2]=(p+a)/d):l>M?(d=Math.sqrt(1+l-c-M)*2,t[3]=(p-a)/d,t[0]=(i+h)/d,t[1]=.25*d,t[2]=(o+m)/d):(d=Math.sqrt(1+M-c-l)*2,t[3]=(i-h)/d,t[0]=(p+a)/d,t[1]=(o+m)/d,t[2]=.25*d),t}static decompose(t,s,n,e){s[0]=e[12],s[1]=e[13],s[2]=e[14];const r=e[0],c=e[1],i=e[2],a=e[4],h=e[5],l=e[6],o=e[8],p=e[9],m=e[10];n[0]=Math.sqrt(r*r+c*c+i*i),n[1]=Math.sqrt(a*a+h*h+l*l),n[2]=Math.sqrt(o*o+p*p+m*m);const M=1/n[0],y=1/n[1],d=1/n[2],g=r*M,f=c*y,T=i*d,x=a*M,w=h*y,E=l*d,z=o*M,P=p*y,F=m*d,O=g+w+F;let S=0;return O>0?(S=Math.sqrt(O+1)*2,t[3]=.25*S,t[0]=(E-P)/S,t[1]=(z-T)/S,t[2]=(f-x)/S):g>w&&g>F?(S=Math.sqrt(1+g-w-F)*2,t[3]=(E-P)/S,t[0]=.25*S,t[1]=(f+x)/S,t[2]=(z+T)/S):w>F?(S=Math.sqrt(1+w-g-F)*2,t[3]=(z-T)/S,t[0]=(f+x)/S,t[1]=.25*S,t[2]=(E+P)/S):(S=Math.sqrt(1+F-g-w)*2,t[3]=(f-x)/S,t[0]=(z+T)/S,t[1]=(E+P)/S,t[2]=.25*S),t}static fromRotationTranslationScale(t,s,n,e){const r=s[0],c=s[1],i=s[2],a=s[3],h=r+r,l=c+c,o=i+i,p=r*h,m=r*l,M=r*o,y=c*l,d=c*o,g=i*o,f=a*h,T=a*l,x=a*o,w=e[0],E=e[1],z=e[2];return t[0]=(1-(y+g))*w,t[1]=(m+x)*w,t[2]=(M-T)*w,t[3]=0,t[4]=(m-x)*E,t[5]=(1-(p+g))*E,t[6]=(d+f)*E,t[7]=0,t[8]=(M+T)*z,t[9]=(d-f)*z,t[10]=(1-(p+y))*z,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}static fromRotationTranslationScaleOrigin(t,s,n,e,r){const c=s[0],i=s[1],a=s[2],h=s[3],l=c+c,o=i+i,p=a+a,m=c*l,M=c*o,y=c*p,d=i*o,g=i*p,f=a*p,T=h*l,x=h*o,w=h*p,E=e[0],z=e[1],P=e[2],F=r[0],O=r[1],S=r[2],I=(1-(d+f))*E,v=(M+w)*E,D=(y-x)*E,C=(M-w)*z,B=(1-(m+f))*z,j=(g+T)*z,Z=(y+x)*P,$=(g-T)*P,W=(1-(m+d))*P;return t[0]=I,t[1]=v,t[2]=D,t[3]=0,t[4]=C,t[5]=B,t[6]=j,t[7]=0,t[8]=Z,t[9]=$,t[10]=W,t[11]=0,t[12]=n[0]+F-(I*F+C*O+Z*S),t[13]=n[1]+O-(v*F+B*O+$*S),t[14]=n[2]+S-(D*F+j*O+W*S),t[15]=1,t}static fromQuat(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=n+n,a=e+e,h=r+r,l=n*i,o=e*i,p=e*a,m=r*i,M=r*a,y=r*h,d=c*i,g=c*a,f=c*h;return t[0]=1-p-y,t[1]=o+f,t[2]=m-g,t[3]=0,t[4]=o-f,t[5]=1-l-y,t[6]=M+d,t[7]=0,t[8]=m+g,t[9]=M-d,t[10]=1-l-p,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}static frustum(t,s,n,e,r,c,i){const a=1/(n-s),h=1/(r-e),l=1/(c-i);return t[0]=c*2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c*2*h,t[6]=0,t[7]=0,t[8]=(n+s)*a,t[9]=(r+e)*h,t[10]=(i+c)*l,t[11]=-1,t[12]=0,t[13]=0,t[14]=i*c*2*l,t[15]=0,t}static perspectiveNO(t,s,n,e,r){const c=1/Math.tan(s/2);if(t[0]=c/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,r!=null&&r!==1/0){const i=1/(e-r);t[10]=(r+e)*i,t[14]=2*r*e*i}else t[10]=-1,t[14]=-2*e;return t}static perspective(t,s,n,e,r){return t}static perspectiveZO(t,s,n,e,r){const c=1/Math.tan(s/2);if(t[0]=c/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,r!=null&&r!==1/0){const i=1/(e-r);t[10]=r*i,t[14]=r*e*i}else t[10]=-1,t[14]=-e;return t}static perspectiveFromFieldOfView(t,s,n,e){const r=Math.tan(s.upDegrees*Math.PI/180),c=Math.tan(s.downDegrees*Math.PI/180),i=Math.tan(s.leftDegrees*Math.PI/180),a=Math.tan(s.rightDegrees*Math.PI/180),h=2/(i+a),l=2/(r+c);return t[0]=h,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=l,t[6]=0,t[7]=0,t[8]=-((i-a)*h*.5),t[9]=(r-c)*l*.5,t[10]=e/(n-e),t[11]=-1,t[12]=0,t[13]=0,t[14]=e*n/(n-e),t[15]=0,t}static orthoNO(t,s,n,e,r,c,i){const a=1/(s-n),h=1/(e-r),l=1/(c-i);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*h,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*l,t[11]=0,t[12]=(s+n)*a,t[13]=(r+e)*h,t[14]=(i+c)*l,t[15]=1,t}static ortho(t,s,n,e,r,c,i){return t}static orthoZO(t,s,n,e,r,c,i){const a=1/(s-n),h=1/(e-r),l=1/(c-i);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*h,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=l,t[11]=0,t[12]=(s+n)*a,t[13]=(r+e)*h,t[14]=c*l,t[15]=1,t}static lookAt(t,s,n,e){const r=s[0],c=s[1],i=s[2],a=e[0],h=e[1],l=e[2],o=n[0],p=n[1],m=n[2];if(Math.abs(r-o)<q&&Math.abs(c-p)<q&&Math.abs(i-m)<q)return R.identity(t);let M=r-o,y=c-p,d=i-m,g=1/Math.sqrt(M*M+y*y+d*d);M*=g,y*=g,d*=g;let f=h*d-l*y,T=l*M-a*d,x=a*y-h*M;g=Math.sqrt(f*f+T*T+x*x),g?(g=1/g,f*=g,T*=g,x*=g):(f=0,T=0,x=0);let w=y*x-d*T,E=d*f-M*x,z=M*T-y*f;return g=Math.sqrt(w*w+E*E+z*z),g?(g=1/g,w*=g,E*=g,z*=g):(w=0,E=0,z=0),t[0]=f,t[1]=w,t[2]=M,t[3]=0,t[4]=T,t[5]=E,t[6]=y,t[7]=0,t[8]=x,t[9]=z,t[10]=d,t[11]=0,t[12]=-(f*r+T*c+x*i),t[13]=-(w*r+E*c+z*i),t[14]=-(M*r+y*c+d*i),t[15]=1,t}static targetTo(t,s,n,e){const r=s[0],c=s[1],i=s[2],a=e[0],h=e[1],l=e[2];let o=r-n[0],p=c-n[1],m=i-n[2],M=o*o+p*p+m*m;M>0&&(M=1/Math.sqrt(M),o*=M,p*=M,m*=M);let y=h*m-l*p,d=l*o-a*m,g=a*p-h*o;return M=y*y+d*d+g*g,M>0&&(M=1/Math.sqrt(M),y*=M,d*=M,g*=M),t[0]=y,t[1]=d,t[2]=g,t[3]=0,t[4]=p*g-m*d,t[5]=m*y-o*g,t[6]=o*d-p*y,t[7]=0,t[8]=o,t[9]=p,t[10]=m,t[11]=0,t[12]=r,t[13]=c,t[14]=i,t[15]=1,t}static frob(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3]+t[4]*t[4]+t[5]*t[5]+t[6]*t[6]+t[7]*t[7]+t[8]*t[8]+t[9]*t[9]+t[10]*t[10]+t[11]*t[11]+t[12]*t[12]+t[13]*t[13]+t[14]*t[14]+t[15]*t[15])}static add(t,s,n){return t[0]=s[0]+n[0],t[1]=s[1]+n[1],t[2]=s[2]+n[2],t[3]=s[3]+n[3],t[4]=s[4]+n[4],t[5]=s[5]+n[5],t[6]=s[6]+n[6],t[7]=s[7]+n[7],t[8]=s[8]+n[8],t[9]=s[9]+n[9],t[10]=s[10]+n[10],t[11]=s[11]+n[11],t[12]=s[12]+n[12],t[13]=s[13]+n[13],t[14]=s[14]+n[14],t[15]=s[15]+n[15],t}static subtract(t,s,n){return t[0]=s[0]-n[0],t[1]=s[1]-n[1],t[2]=s[2]-n[2],t[3]=s[3]-n[3],t[4]=s[4]-n[4],t[5]=s[5]-n[5],t[6]=s[6]-n[6],t[7]=s[7]-n[7],t[8]=s[8]-n[8],t[9]=s[9]-n[9],t[10]=s[10]-n[10],t[11]=s[11]-n[11],t[12]=s[12]-n[12],t[13]=s[13]-n[13],t[14]=s[14]-n[14],t[15]=s[15]-n[15],t}static sub(t,s,n){return t}static multiplyScalar(t,s,n){return t[0]=s[0]*n,t[1]=s[1]*n,t[2]=s[2]*n,t[3]=s[3]*n,t[4]=s[4]*n,t[5]=s[5]*n,t[6]=s[6]*n,t[7]=s[7]*n,t[8]=s[8]*n,t[9]=s[9]*n,t[10]=s[10]*n,t[11]=s[11]*n,t[12]=s[12]*n,t[13]=s[13]*n,t[14]=s[14]*n,t[15]=s[15]*n,t}static multiplyScalarAndAdd(t,s,n,e){return t[0]=s[0]+n[0]*e,t[1]=s[1]+n[1]*e,t[2]=s[2]+n[2]*e,t[3]=s[3]+n[3]*e,t[4]=s[4]+n[4]*e,t[5]=s[5]+n[5]*e,t[6]=s[6]+n[6]*e,t[7]=s[7]+n[7]*e,t[8]=s[8]+n[8]*e,t[9]=s[9]+n[9]*e,t[10]=s[10]+n[10]*e,t[11]=s[11]+n[11]*e,t[12]=s[12]+n[12]*e,t[13]=s[13]+n[13]*e,t[14]=s[14]+n[14]*e,t[15]=s[15]+n[15]*e,t}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]&&t[3]===s[3]&&t[4]===s[4]&&t[5]===s[5]&&t[6]===s[6]&&t[7]===s[7]&&t[8]===s[8]&&t[9]===s[9]&&t[10]===s[10]&&t[11]===s[11]&&t[12]===s[12]&&t[13]===s[13]&&t[14]===s[14]&&t[15]===s[15]}static equals(t,s){const n=t[0],e=t[1],r=t[2],c=t[3],i=t[4],a=t[5],h=t[6],l=t[7],o=t[8],p=t[9],m=t[10],M=t[11],y=t[12],d=t[13],g=t[14],f=t[15],T=s[0],x=s[1],w=s[2],E=s[3],z=s[4],P=s[5],F=s[6],O=s[7],S=s[8],I=s[9],v=s[10],D=s[11],C=s[12],B=s[13],j=s[14],Z=s[15];return Math.abs(n-T)<=q*Math.max(1,Math.abs(n),Math.abs(T))&&Math.abs(e-x)<=q*Math.max(1,Math.abs(e),Math.abs(x))&&Math.abs(r-w)<=q*Math.max(1,Math.abs(r),Math.abs(w))&&Math.abs(c-E)<=q*Math.max(1,Math.abs(c),Math.abs(E))&&Math.abs(i-z)<=q*Math.max(1,Math.abs(i),Math.abs(z))&&Math.abs(a-P)<=q*Math.max(1,Math.abs(a),Math.abs(P))&&Math.abs(h-F)<=q*Math.max(1,Math.abs(h),Math.abs(F))&&Math.abs(l-O)<=q*Math.max(1,Math.abs(l),Math.abs(O))&&Math.abs(o-S)<=q*Math.max(1,Math.abs(o),Math.abs(S))&&Math.abs(p-I)<=q*Math.max(1,Math.abs(p),Math.abs(I))&&Math.abs(m-v)<=q*Math.max(1,Math.abs(m),Math.abs(v))&&Math.abs(M-D)<=q*Math.max(1,Math.abs(M),Math.abs(D))&&Math.abs(y-C)<=q*Math.max(1,Math.abs(y),Math.abs(C))&&Math.abs(d-B)<=q*Math.max(1,Math.abs(d),Math.abs(B))&&Math.abs(g-j)<=q*Math.max(1,Math.abs(g),Math.abs(j))&&Math.abs(f-Z)<=q*Math.max(1,Math.abs(f),Math.abs(Z))}static str(t){return`Mat4(${t.join(", ")})`}}const X=new A;R.prototype.mul=R.prototype.multiply;R.sub=R.subtract;R.mul=R.multiply;R.perspective=R.perspectiveNO;R.ortho=R.orthoNO;class b extends Float32Array{static BYTE_LENGTH=4*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 4:super(t);break;case 2:super(t[0],t[1],4);break;case 1:{const s=t[0];typeof s=="number"?super([s,s,s,s]):super(s,0,4);break}default:super(4);break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get w(){return this[3]}set w(t){this[3]=t}get r(){return this[0]}set r(t){this[0]=t}get g(){return this[1]}set g(t){this[1]=t}get b(){return this[2]}set b(t){this[2]=t}get a(){return this[3]}set a(t){this[3]=t}get magnitude(){const t=this[0],s=this[1],n=this[2],e=this[3];return Math.sqrt(t*t+s*s+n*n+e*e)}get mag(){return this.magnitude}get str(){return b.str(this)}copy(t){return super.set(t),this}add(t){return this[0]+=t[0],this[1]+=t[1],this[2]+=t[2],this[3]+=t[3],this}subtract(t){return this[0]-=t[0],this[1]-=t[1],this[2]-=t[2],this[3]-=t[3],this}sub(t){return this}multiply(t){return this[0]*=t[0],this[1]*=t[1],this[2]*=t[2],this[3]*=t[3],this}mul(t){return this}divide(t){return this[0]/=t[0],this[1]/=t[1],this[2]/=t[2],this[3]/=t[3],this}div(t){return this}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this[3]*=t,this}scaleAndAdd(t,s){return this[0]+=t[0]*s,this[1]+=t[1]*s,this[2]+=t[2]*s,this[3]+=t[3]*s,this}distance(t){return b.distance(this,t)}dist(t){return 0}squaredDistance(t){return b.squaredDistance(this,t)}sqrDist(t){return 0}negate(){return this[0]*=-1,this[1]*=-1,this[2]*=-1,this[3]*=-1,this}invert(){return this[0]=1/this[0],this[1]=1/this[1],this[2]=1/this[2],this[3]=1/this[3],this}dot(t){return this[0]*t[0]+this[1]*t[1]+this[2]*t[2]+this[3]*t[3]}normalize(){return b.normalize(this,this)}static create(){return new b}static clone(t){return new b(t)}static fromValues(t,s,n,e){return new b(t,s,n,e)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t}static set(t,s,n,e,r){return t[0]=s,t[1]=n,t[2]=e,t[3]=r,t}static add(t,s,n){return t[0]=s[0]+n[0],t[1]=s[1]+n[1],t[2]=s[2]+n[2],t[3]=s[3]+n[3],t}static subtract(t,s,n){return t[0]=s[0]-n[0],t[1]=s[1]-n[1],t[2]=s[2]-n[2],t[3]=s[3]-n[3],t}static sub(t,s,n){return t}static multiply(t,s,n){return t[0]=s[0]*n[0],t[1]=s[1]*n[1],t[2]=s[2]*n[2],t[3]=s[3]*n[3],t}static mul(t,s,n){return t}static divide(t,s,n){return t[0]=s[0]/n[0],t[1]=s[1]/n[1],t[2]=s[2]/n[2],t[3]=s[3]/n[3],t}static div(t,s,n){return t}static ceil(t,s){return t[0]=Math.ceil(s[0]),t[1]=Math.ceil(s[1]),t[2]=Math.ceil(s[2]),t[3]=Math.ceil(s[3]),t}static floor(t,s){return t[0]=Math.floor(s[0]),t[1]=Math.floor(s[1]),t[2]=Math.floor(s[2]),t[3]=Math.floor(s[3]),t}static min(t,s,n){return t[0]=Math.min(s[0],n[0]),t[1]=Math.min(s[1],n[1]),t[2]=Math.min(s[2],n[2]),t[3]=Math.min(s[3],n[3]),t}static max(t,s,n){return t[0]=Math.max(s[0],n[0]),t[1]=Math.max(s[1],n[1]),t[2]=Math.max(s[2],n[2]),t[3]=Math.max(s[3],n[3]),t}static round(t,s){return t[0]=Math.round(s[0]),t[1]=Math.round(s[1]),t[2]=Math.round(s[2]),t[3]=Math.round(s[3]),t}static scale(t,s,n){return t[0]=s[0]*n,t[1]=s[1]*n,t[2]=s[2]*n,t[3]=s[3]*n,t}static scaleAndAdd(t,s,n,e){return t[0]=s[0]+n[0]*e,t[1]=s[1]+n[1]*e,t[2]=s[2]+n[2]*e,t[3]=s[3]+n[3]*e,t}static distance(t,s){const n=s[0]-t[0],e=s[1]-t[1],r=s[2]-t[2],c=s[3]-t[3];return Math.hypot(n,e,r,c)}static dist(t,s){return 0}static squaredDistance(t,s){const n=s[0]-t[0],e=s[1]-t[1],r=s[2]-t[2],c=s[3]-t[3];return n*n+e*e+r*r+c*c}static sqrDist(t,s){return 0}static magnitude(t){const s=t[0],n=t[1],e=t[2],r=t[3];return Math.sqrt(s*s+n*n+e*e+r*r)}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static squaredLength(t){const s=t[0],n=t[1],e=t[2],r=t[3];return s*s+n*n+e*e+r*r}static sqrLen(t){return 0}static negate(t,s){return t[0]=-s[0],t[1]=-s[1],t[2]=-s[2],t[3]=-s[3],t}static inverse(t,s){return t[0]=1/s[0],t[1]=1/s[1],t[2]=1/s[2],t[3]=1/s[3],t}static normalize(t,s){const n=s[0],e=s[1],r=s[2],c=s[3];let i=n*n+e*e+r*r+c*c;return i>0&&(i=1/Math.sqrt(i)),t[0]=n*i,t[1]=e*i,t[2]=r*i,t[3]=c*i,t}static dot(t,s){return t[0]*s[0]+t[1]*s[1]+t[2]*s[2]+t[3]*s[3]}static cross(t,s,n,e){const r=n[0]*e[1]-n[1]*e[0],c=n[0]*e[2]-n[2]*e[0],i=n[0]*e[3]-n[3]*e[0],a=n[1]*e[2]-n[2]*e[1],h=n[1]*e[3]-n[3]*e[1],l=n[2]*e[3]-n[3]*e[2],o=s[0],p=s[1],m=s[2],M=s[3];return t[0]=p*l-m*h+M*a,t[1]=-(o*l)+m*i-M*c,t[2]=o*h-p*i+M*r,t[3]=-(o*a)+p*c-m*r,t}static lerp(t,s,n,e){const r=s[0],c=s[1],i=s[2],a=s[3];return t[0]=r+e*(n[0]-r),t[1]=c+e*(n[1]-c),t[2]=i+e*(n[2]-i),t[3]=a+e*(n[3]-a),t}static transformMat4(t,s,n){const e=s[0],r=s[1],c=s[2],i=s[3];return t[0]=n[0]*e+n[4]*r+n[8]*c+n[12]*i,t[1]=n[1]*e+n[5]*r+n[9]*c+n[13]*i,t[2]=n[2]*e+n[6]*r+n[10]*c+n[14]*i,t[3]=n[3]*e+n[7]*r+n[11]*c+n[15]*i,t}static transformQuat(t,s,n){const e=s[0],r=s[1],c=s[2],i=n[0],a=n[1],h=n[2],l=n[3],o=l*e+a*c-h*r,p=l*r+h*e-i*c,m=l*c+i*r-a*e,M=-i*e-a*r-h*c;return t[0]=o*l+M*-i+p*-h-m*-a,t[1]=p*l+M*-a+m*-i-o*-h,t[2]=m*l+M*-h+o*-a-p*-i,t[3]=s[3],t}static zero(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}static str(t){return`Vec4(${t.join(", ")})`}static exactEquals(t,s){return t[0]===s[0]&&t[1]===s[1]&&t[2]===s[2]&&t[3]===s[3]}static equals(t,s){const n=t[0],e=t[1],r=t[2],c=t[3],i=s[0],a=s[1],h=s[2],l=s[3];return Math.abs(n-i)<=q*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(e-a)<=q*Math.max(1,Math.abs(e),Math.abs(a))&&Math.abs(r-h)<=q*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(c-l)<=q*Math.max(1,Math.abs(c),Math.abs(l))}}b.prototype.sub=b.prototype.subtract;b.prototype.mul=b.prototype.multiply;b.prototype.div=b.prototype.divide;b.prototype.dist=b.prototype.distance;b.prototype.sqrDist=b.prototype.squaredDistance;b.sub=b.subtract;b.mul=b.multiply;b.div=b.divide;b.dist=b.distance;b.sqrDist=b.squaredDistance;b.sqrLen=b.squaredLength;b.mag=b.magnitude;b.length=b.magnitude;b.len=b.magnitude;class L extends Float32Array{static BYTE_LENGTH=4*Float32Array.BYTES_PER_ELEMENT;constructor(...t){switch(t.length){case 4:super(t);break;case 2:super(t[0],t[1],4);break;case 1:{const s=t[0];typeof s=="number"?super([s,s,s,s]):super(s,0,4);break}default:super(4),this[3]=1;break}}get x(){return this[0]}set x(t){this[0]=t}get y(){return this[1]}set y(t){this[1]=t}get z(){return this[2]}set z(t){this[2]=t}get w(){return this[3]}set w(t){this[3]=t}get magnitude(){const t=this[0],s=this[1],n=this[2],e=this[3];return Math.sqrt(t*t+s*s+n*n+e*e)}get mag(){return this.magnitude}get str(){return L.str(this)}copy(t){return super.set(t),this}identity(){return this[0]=0,this[1]=0,this[2]=0,this[3]=1,this}multiply(t){return L.multiply(this,this,t)}mul(t){return this}rotateX(t){return L.rotateX(this,this,t)}rotateY(t){return L.rotateY(this,this,t)}rotateZ(t){return L.rotateZ(this,this,t)}invert(){return L.invert(this,this)}scale(t){return this[0]*=t,this[1]*=t,this[2]*=t,this[3]*=t,this}dot(t){return L.dot(this,t)}static create(){return new L}static identity(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}static setAxisAngle(t,s,n){n=n*.5;const e=Math.sin(n);return t[0]=e*s[0],t[1]=e*s[1],t[2]=e*s[2],t[3]=Math.cos(n),t}static getAxisAngle(t,s){const n=Math.acos(s[3])*2,e=Math.sin(n/2);return e>q?(t[0]=s[0]/e,t[1]=s[1]/e,t[2]=s[2]/e):(t[0]=1,t[1]=0,t[2]=0),n}static getAngle(t,s){const n=L.dot(t,s);return Math.acos(2*n*n-1)}static multiply(t,s,n){const e=s[0],r=s[1],c=s[2],i=s[3],a=n[0],h=n[1],l=n[2],o=n[3];return t[0]=e*o+i*a+r*l-c*h,t[1]=r*o+i*h+c*a-e*l,t[2]=c*o+i*l+e*h-r*a,t[3]=i*o-e*a-r*h-c*l,t}static rotateX(t,s,n){n*=.5;const e=s[0],r=s[1],c=s[2],i=s[3],a=Math.sin(n),h=Math.cos(n);return t[0]=e*h+i*a,t[1]=r*h+c*a,t[2]=c*h-r*a,t[3]=i*h-e*a,t}static rotateY(t,s,n){n*=.5;const e=s[0],r=s[1],c=s[2],i=s[3],a=Math.sin(n),h=Math.cos(n);return t[0]=e*h-c*a,t[1]=r*h+i*a,t[2]=c*h+e*a,t[3]=i*h-r*a,t}static rotateZ(t,s,n){n*=.5;const e=s[0],r=s[1],c=s[2],i=s[3],a=Math.sin(n),h=Math.cos(n);return t[0]=e*h+r*a,t[1]=r*h-e*a,t[2]=c*h+i*a,t[3]=i*h-c*a,t}static calculateW(t,s){const n=s[0],e=s[1],r=s[2];return t[0]=n,t[1]=e,t[2]=r,t[3]=Math.sqrt(Math.abs(1-n*n-e*e-r*r)),t}static exp(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=Math.sqrt(n*n+e*e+r*r),a=Math.exp(c),h=i>0?a*Math.sin(i)/i:0;return t[0]=n*h,t[1]=e*h,t[2]=r*h,t[3]=a*Math.cos(i),t}static ln(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=Math.sqrt(n*n+e*e+r*r),a=i>0?Math.atan2(i,c)/i:0;return t[0]=n*a,t[1]=e*a,t[2]=r*a,t[3]=.5*Math.log(n*n+e*e+r*r+c*c),t}static pow(t,s,n){return L.ln(t,s),L.scale(t,t,n),L.exp(t,t),t}static slerp(t,s,n,e){const r=s[0],c=s[1],i=s[2],a=s[3];let h=n[0],l=n[1],o=n[2],p=n[3],m,M,y=r*h+c*l+i*o+a*p;if(y<0&&(y=-y,h=-h,l=-l,o=-o,p=-p),1-y>q){const d=Math.acos(y),g=Math.sin(d);m=Math.sin((1-e)*d)/g,M=Math.sin(e*d)/g}else m=1-e,M=e;return t[0]=m*r+M*h,t[1]=m*c+M*l,t[2]=m*i+M*o,t[3]=m*a+M*p,t}static invert(t,s){const n=s[0],e=s[1],r=s[2],c=s[3],i=n*n+e*e+r*r+c*c,a=i?1/i:0;return t[0]=-n*a,t[1]=-e*a,t[2]=-r*a,t[3]=c*a,t}static conjugate(t,s){return t[0]=-s[0],t[1]=-s[1],t[2]=-s[2],t[3]=s[3],t}static fromMat3(t,s){const n=s[0]+s[4]+s[8];let e;if(n>0)e=Math.sqrt(n+1),t[3]=.5*e,e=.5/e,t[0]=(s[5]-s[7])*e,t[1]=(s[6]-s[2])*e,t[2]=(s[1]-s[3])*e;else{let r=0;s[4]>s[0]&&(r=1),s[8]>s[r*3+r]&&(r=2);let c=(r+1)%3,i=(r+2)%3;e=Math.sqrt(s[r*3+r]-s[c*3+c]-s[i*3+i]+1),t[r]=.5*e,e=.5/e,t[3]=(s[c*3+i]-s[i*3+c])*e,t[c]=(s[c*3+r]+s[r*3+c])*e,t[i]=(s[i*3+r]+s[r*3+i])*e}return t}static fromEuler(t,s,n,e){let r=.5*Math.PI/180;s*=r,n*=r,e*=r;let c=Math.sin(s),i=Math.cos(s),a=Math.sin(n),h=Math.cos(n),l=Math.sin(e),o=Math.cos(e);return t[0]=c*h*o-i*a*l,t[1]=i*a*o+c*h*l,t[2]=i*h*l-c*a*o,t[3]=i*h*o+c*a*l,t}static str(t){return`Quat(${t.join(", ")})`}static clone(t){return new L(t)}static fromValues(t,s,n,e){return new L(t,s,n,e)}static copy(t,s){return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t}static set(t,s,n,e,r){return t}static add(t,s,n){return t}static mul(t,s,n){return t}static scale(t,s,n){return t[0]=s[0]*n,t[1]=s[1]*n,t[2]=s[2]*n,t[3]=s[3]*n,t}static dot(t,s){return t[0]*s[0]+t[1]*s[1]+t[2]*s[2]+t[3]*s[3]}static lerp(t,s,n,e){return t}static magnitude(t){return 0}static mag(t){return 0}static length(t){return 0}static len(t){return 0}static squaredLength(t){return 0}static sqrLen(t){return 0}static normalize(t,s){return t}static exactEquals(t,s){return!1}static equals(t,s){return!1}static rotationTo(t,s,n){let e=A.dot(s,n);return e<-.999999?(A.cross(k,rt,s),A.len(k)<1e-6&&A.cross(k,ct,s),A.normalize(k,k),L.setAxisAngle(t,k,Math.PI),t):e>.999999?(t[0]=0,t[1]=0,t[2]=0,t[3]=1,t):(A.cross(k,s,n),t[0]=k[0],t[1]=k[1],t[2]=k[2],t[3]=1+e,L.normalize(t,t))}static sqlerp(t,s,n,e,r,c){return L.slerp(Q,s,r,c),L.slerp(_,n,e,c),L.slerp(t,Q,_,2*c*(1-c)),t}static setAxes(t,s,n,e){return Y[0]=n[0],Y[3]=n[1],Y[6]=n[2],Y[1]=e[0],Y[4]=e[1],Y[7]=e[2],Y[2]=-s[0],Y[5]=-s[1],Y[8]=-s[2],L.normalize(t,L.fromMat3(t,Y))}}const Q=new L,_=new L,Y=new N,k=new A,rt=new A(1,0,0),ct=new A(0,1,0);L.set=b.set;L.add=b.add;L.lerp=b.lerp;L.normalize=b.normalize;L.squaredLength=b.squaredLength;L.sqrLen=b.squaredLength;L.exactEquals=b.exactEquals;L.equals=b.equals;L.magnitude=b.magnitude;L.prototype.mul=L.prototype.multiply;L.mul=L.multiply;L.mag=L.magnitude;L.length=L.magnitude;L.len=L.magnitude;class V{fov;aspect;near;far;constructor(t=60,s=1,n=.1,e=1e3){this.fov=t,this.aspect=s,this.near=n,this.far=e}getProjectionMatrix(){let t=new R;return R.perspectiveNO(t,this.fov*Math.PI/180,this.aspect,this.near,this.far),t}}class it{type;color;intensity;constructor(t="point",s=new A(1,1,1),n=1){this.type=t,this.color=s,this.intensity=n}}class tt{vao=null;vertexCount=0;constructor(t=null,s=0){this.vao=t,this.vertexCount=s}}class H{position=new A(0,0,0);rotation=new L(0,0,0,1);scale=new A(1,1,1);constructor(){}setPosition(t){this.position=t}setRotationQuat(t){this.rotation=t}setRotationEuler(t){L.fromEuler(this.rotation,t.x,t.y,t.z)}setScale(t){this.position=t}getPosition(){return this.position}getRotation(){return this.rotation}getRotationEuler(){return this.toEulerXYZ(this.rotation)}toEulerXYZ(t){const s=t.w*t.x,n=t.w*t.y,e=t.w*t.z,r=t.x*t.x,c=t.x*t.y,i=t.x*t.z,a=t.y*t.y,h=t.y*t.z,l=t.z*t.z;return new A(-Math.atan2(2*(h-s),1-2*(r+a))*180/Math.PI,Math.asin(2*(i+n))*180/Math.PI,-Math.atan2(2*(c-e),1-2*(a+l))*180/Math.PI)}getScale(){return this.scale}getLocalMatrix(){const t=new R;return R.fromRotationTranslationScale(t,this.rotation,this.position,this.scale),t}getViewMatrix(){const t=new R,s=new L;L.invert(s,this.rotation);const n=new A;return A.negate(n,this.position),A.transformQuat(n,n,s),R.fromRotationTranslation(t,s,n),t}}class at{nextId=0;entities=new Set;constructor(){}create(){const t=this.nextId++;return this.entities.add(t),t}destroy(t){this.entities.delete(t)}getAll(){return Array.from(this.entities)}}class ht{systems=[];add(t){this.systems.push(t)}update(t,s){for(const n of this.systems)n.update(t,s)}}class lt{entities;components;systems;constructor(){this.entities=new at,this.components=new et,this.systems=new ht}createEntity(){const t=this.entities.create();return this.components.add(t,new H),t}createCamera(){const t=this.createEntity();return this.components.add(t,new V),t}createLight(t){const s=this.createEntity();return this.components.add(s,new it(t)),s}createMesh(t,s){const n=this.createEntity();return this.components.add(n,new tt(t.vao,t.vertexCount)),this.components.add(n,s),n}}class ot{ecs;name;active;activeCamera=null;constructor(t="Untitled"){this.name=t,this.active=!0,this.ecs=new lt}update(t){this.active&&this.ecs.systems.update(t,this.ecs.components)}createCamera(){const t=this.ecs.createCamera();return this.activeCamera===null&&(this.activeCamera=t),t}setActiveCamera(t){if(!this.ecs.components.get(t,V))throw new Error("L'entité donnée n'a pas de composant Camera");this.activeCamera=t}getActiveCamera(){return this.activeCamera}createEntity(){return this.ecs.createEntity()}createLight(t){return this.ecs.createLight(t)}createMesh(t,s){return this.ecs.createMesh(t,s)}destroyEntity(t){t===this.activeCamera&&(this.activeCamera=null),this.ecs.entities.destroy(t)}getComponent(t,s){return this.ecs.components.get(t,s)}getAllComponentOfType(t){return this.ecs.components.getAllOfType(t)}}class Mt{gl;constructor(t){const s=t.getContext("webgl2");if(s)console.log("WebGL2 context initialized",s);else throw new Error("WebGL2 non supporté par ce navigateur");this.gl=s,this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT),this.gl.enable(this.gl.BLEND),this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA);const n=["EXT_color_buffer_float","OES_texture_float_linear","EXT_texture_filter_anisotropic"];for(const e of n)s.getExtension(e)}clear(t=0,s=0,n=0,e=1){this.gl.clearColor(t,s,n,e),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT)}setViewport(t,s){console.log("Set viewport",t,s),this.gl.viewport(0,0,t,s)}enableDepthTest(){this.gl.enable(this.gl.DEPTH_TEST)}}class st{shader;uniforms={};constructor(t){this.shader=t}setUniform(t,s){this.uniforms[t]=s}applyUniforms(){for(const[t,s]of Object.entries(this.uniforms))this.shader.setUniform(t,s)}}class mt{glContext;constructor(t){this.glContext=t}render(t){const s=t.getActiveCamera();if(!s)throw new Error("No active camera in the scene");this.glContext.clear(0,0,1,1);const n=t.getComponent(s,V),e=t.getComponent(s,H),r=t.getAllComponentOfType(tt),c=e.getViewMatrix(),i=n.getProjectionMatrix();for(const[a,h]of r){const l=t.getComponent(a,H),o=t.getComponent(a,st);!l||!o||(o.shader.use(),o.shader.setUniform("u_proj",i),o.shader.setUniform("u_view",c),o.shader.setUniform("u_model",l.getLocalMatrix()),o.applyUniforms(),h.vao&&(this.glContext.gl.bindVertexArray(h.vao),this.glContext.gl.drawArrays(this.glContext.gl.TRIANGLES,0,h.vertexCount),this.glContext.gl.bindVertexArray(null)))}}}class pt{lastTime=0;glContext;renderer;scene=null;constructor(t){this.glContext=new Mt(t),this.renderer=new mt(this.glContext)}start(){let t=performance.now();const s=n=>{const e=(n-t)/1e3;t=n,this.scene&&(this.scene.update(e),this.renderer.render(this.scene)),requestAnimationFrame(s)};requestAnimationFrame(s)}setScene(t){this.scene=t}}class yt{gl;program;uniformLocations=new Map;constructor(t,s,n){this.gl=t;const e=this.compile(t.VERTEX_SHADER,s),r=this.compile(t.FRAGMENT_SHADER,n),c=t.createProgram();if(!c)throw new Error("Impossible de créer le programme WebGL.");if(t.attachShader(c,e),t.attachShader(c,r),t.linkProgram(c),!t.getProgramParameter(c,t.LINK_STATUS)){const i=t.getProgramInfoLog(c);throw new Error("Erreur de linkage du shader: "+i)}t.deleteShader(e),t.deleteShader(r),this.program=c}use(){this.gl.useProgram(this.program)}getUniformLocation(t){if(this.uniformLocations.has(t))return this.uniformLocations.get(t);const s=this.gl.getUniformLocation(this.program,t);if(!s)throw new Error(`Uniform "${t}" introuvable dans le shader.`);return this.uniformLocations.set(t,s),s}setUniform(t,s){const n=this.getUniformLocation(t),e={1:(c,i)=>typeof i=="number"?this.gl.uniform1f(c,i):this.gl.uniform1iv(c,i),2:(c,i)=>this.gl.uniform2fv(c,i),3:(c,i)=>this.gl.uniform3fv(c,i),4:(c,i)=>Array.isArray(i)||i instanceof Float32Array?this.gl.uniform4fv(c,i):this.gl.uniformMatrix2fv(c,!1,i),9:(c,i)=>this.gl.uniformMatrix3fv(c,!1,i),16:(c,i)=>this.gl.uniformMatrix4fv(c,!1,i)},r=typeof s=="number"?1:s.length;e[r](n,s)}compile(t,s){const n=this.gl.createShader(t);if(!n)throw new Error("Cannot create shader.");if(this.gl.shaderSource(n,s),this.gl.compileShader(n),!this.gl.getShaderParameter(n,this.gl.COMPILE_STATUS)){const e=this.gl.getShaderInfoLog(n);throw new Error("Shader compilation error: "+e)}return n}delete(){this.gl.deleteProgram(this.program)}}class u{static LoadFromURL(t){return""}static stdVertexShader(){return`#version 300 es
        precision highp float;

        in vec3 a_position;

        uniform mat4 u_proj;
        uniform mat4 u_view;
        uniform mat4 u_model;


        void main() {
            vec4 worldPos = u_model * vec4(a_position, 1.0);
            gl_Position = u_proj * u_view * worldPos;
        }
        `}static stdFragmentShader(){return`#version 300 es
        precision highp float;
        out vec4 outColor;
        void main() {
            outColor = vec4(1.0,0.0,0.0, 1.0);
        }
    `}}class G{static LoadFromURL(t,s){return null}static generateTriangle(t){const s=[-.5,.5,0,-.5,-.5,0,.5,-.5,0],n=[0,1,2];return G.generateVAO(t,s,n)}static cube(t){const s=[-.5,.5,0,-.5,-.5,0,.5,-.5,0],n=[0,1,2];return G.generateVAO(t,s,n)}static generateVAO(t,s,n){const e=t.createVertexArray();t.bindVertexArray(e);const r=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,r),t.bufferData(t.ARRAY_BUFFER,new Float32Array(s),t.STATIC_DRAW);const c=t.createBuffer();return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,c),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array(n),t.STATIC_DRAW),{vao:e,vertexCount:s.length}}}function dt(U){console.log("Initializing Engine...");const t=new pt(U);console.log("Initializing Scene...");const s=new ot,n=new yt(t.glContext.gl,u.stdVertexShader(),u.stdFragmentShader()),e=s.ecs.createMesh(G.generateTriangle(t.glContext.gl),new st(n));s.getComponent(e,H).setPosition(new A(0,0,0)),s.ecs.createCamera(),t.setScene(s),console.log("Start engine..."),t.start(),console.log("Engine started.")}let nt=document.querySelector("#glCanvas");console.log(nt);dt(nt);
